<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Big Book of Rust Interop</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="estimating.html"><strong aria-hidden="true">2.</strong> Assessing/estimating interop complexity</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Building and linking</div></li><li class="chapter-item expanded "><a href="mechanics/index.html"><strong aria-hidden="true">4.</strong> Bindings and representations</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Building an abstraction layer</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Modularisation</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> Safety</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Ownership and memory management - mem::forget</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.</strong> FFI types and idiomatic types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> Error handling</div></li></ol></li><li class="chapter-item expanded "><a href="patterns/index.html"><strong aria-hidden="true">6.</strong> Patterns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="patterns/layered.html"><strong aria-hidden="true">6.1.</strong> Layered library design</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Case studies</div></li><li class="chapter-item expanded "><a href="reference/index.html"><strong aria-hidden="true">8.</strong> Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/functions.html"><strong aria-hidden="true">8.1.</strong> Functions and methods</a></li><li class="chapter-item expanded "><a href="reference/data-types.html"><strong aria-hidden="true">8.2.</strong> Data types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/numerics.html"><strong aria-hidden="true">8.2.1.</strong> Numeric types</a></li><li class="chapter-item expanded "><a href="reference/strings.html"><strong aria-hidden="true">8.2.2.</strong> Strings</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="resources.html"><strong aria-hidden="true">9.</strong> Resources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Big Book of Rust Interop</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>It is extremely common to integrate multiple languages in a single program or system. This might occur due to different languages being better suited for different components, requiring new code to work with old code written in an older language, or when incrementally adopting a new language.</p>
<p>In some cases, different languages can be isolated in different processes (either on the same machine or different ones), language interoperation is then just a matter of finding compatible IPC solutions. Where this isn't feasible, libraries produced by different compilers will be linked together into the same executable and run together in the same process.</p>
<p>In the Rust world, the most common foreign language to interoperate with is C. Interop between Rust and C is easier than much other language interop because neither language has a required runtime, Rust has built-in support for interoperating with C and for the C ABI, and there are good supporting tools. However, there are many rough edges, and dealing with the difference in safety invariants is an involved task.</p>
<p>Stepping back, there are two aspects of Rust interop: the mechanics of aligning runtime semantics across different languages, and ensuring Rust's safety invariants are upheld. With interop between Rust and C, the former is mostly solved by tooling and built-in features. For interop between Rust and C++ or other languages, there is more work to do (work which is often specific to a project, rather than being a reusable solution). The safety aspect is solved by designing a safe API for foreign components. Some techniques for this are generic and apply to most situations, some are specific to the constraints of a project.</p>
<p>TODO - organisation of docs</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>When you need Rust code to work with code written in another language (we'll often call this a foreign language), there are two ways to do it: the code can be kept in different executables running in different processes or the code can be linked together and run in the same process. Code in different processes makes the language-specific issues much easier, but communication must happen by IPC which can complicate design and performance. Rust has good support for several IPC mechanisms, so this is a good option, where it is possible. If your system requires closer integration, then code must be separately compiled and linked together. Code written in different languages must then interoperate, that is functions are called across the language boundary and data is passed from one language to another. Such interop is the subject of these docs.</p>
<h2 id="a-high-level-view-of-interop"><a class="header" href="#a-high-level-view-of-interop">A high-level view of interop</a></h2>
<p>A programming language gives semantics to source code which is compiled to machine code. When we have two programming languages, we have two different sets of semantics which are compiled differently into machine code. For the programming languages to interoperate, they must have a shared understanding of the semantics behind the machine code, at least enough for communication. In practice, this means functions must have compatible ABIs and data must have a representation in memory which is known to both languages and compatible with both languages. Representation and ABI combine to produce features like dynamic dispatch of methods and implicit adjustment of types such as referencing or dereferencing pointers.</p>
<p>Furthermore, a programming language's semantics extends beyond the nuts and bolts of ABI and representation to concepts of correctness and validity. For Rust, these semantics give rise to Rust's guarantees around memory safety. For interop, we must ensure that a programming language's expectations of validity are not subverted by foreign code.</p>
<p>In both the abstract, and in the concrete design of interoperating programs, we can think of interop as two layers: a reflection of foreign code into Rust (that is, bindings for foreign functions and Rust declarations of data types which have parallel foreign declarations), and an abstraction layer (which provides some of the higher level semantics of the foreign language and Rust, and provides a more idiomatic interface).</p>
<p>This guide aims to provide a precise understanding of issues around the mechanical layer of interop. That should facilitate writing tools for generating bindings, or for writing or editing bindings by hand. The abstraction layer of interop is fundamentally a design problem rather than a tooling problem and projects will require mostly unique solutions. This guide will aim to describe design patterns, best practices, and issues to help you solve the design problem.</p>
<p>As with much software design, the key to successful interop is modularity. The more you can isolate code from different languages and the more you can draw strong boundaries, the easier interop will be. The more fine-grained your interop must be, and the more closely foreign code must be integrated, the harder things get.</p>
<p>To give some concrete examples, passing around foreign objects opaquely is much easier than if you need to operate on those objects, calling straightforward functions is easy but calling virtually dispatched functions is more difficult, accessing data via well-encapsulated functions is much easier than accessing and manipulating data directly.</p>
<h3 id="other-languages"><a class="header" href="#other-languages">Other languages</a></h3>
<p>In this guide, we'll mostly cover interop with C and C++ because that is the most common and most fundamental integration. Rust interoperating with other languages is very much possible, but is a less well-trodden path. Different languages have different issues and different levels of existing tooling. As described above, the issues come down to making different languages agree on the semantics of representation, operation, and correctness.</p>
<p>Any language which provides a mechanism for interop with C can also interoperate with Rust. This can be done with an intermediate C library, or by directly binding foreign functions and data types in Rust. In some cases we can do better than this since the foreign langauge and Rust might share some features or invariants which are lost when translating to C as an intermediate step.</p>
<h1 id="old-text"><a class="header" href="#old-text">Old text</a></h1>
<p>TODO most of this is copy/pasted from the old doc, the rest needs updating to the new layout</p>
<p>The good news is that interop is extremely low cost (interop with C is cheap and interop with other languages is no more expensive than interop with C) and the fundamentals (ABI compatibility of many datatypes and functions, extern declarations, etc.) are built in to Rust. In many cases, there is no need for data marshalling or serialization, or adaptation for calling conventions, etc. Calling a Rust function from C or vice versa is no more expensive than calling a C function in a different library (and since LTO works across the language boundary, it can even be as cheap as a within the same file).</p>
<p>Generally speaking, Rust is ABI-compatible with C. That means that Rust can interoperate with any language which can interoperate with C (though FFI with languages other than C is likely to be more complex and to have some runtime overhead). There is community support for interop with C++, Ruby, Javascript, and Python. Interop with .net and Java is supported via P/Invoke and JNI respectively.</p>
<p>TODO:</p>
<ul>
<li>mechanics vs safety (FFI types vs idiomatic types)</li>
<li>levels of abstraction (making FFI ergonomic/idiomatic)</li>
<li>ffi and safety, and what is the challenge to writing an FFI layer</li>
<li>differences with other interop (managed langs, etc)</li>
<li>assessing the feasibility/difficulty of interop</li>
<li>Kinds of interop - C lib, Rust lib, mixed program, etc.</li>
<li>using a library vs building a library</li>
</ul>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>The more well-defined the boundary between Rust and foreign code, the easier things will be. At the limit, if your Rust and foreign code can live in different processes (i.e., are different programs compiled separately) and can communicate via some form of IPC then you won't have to worry about a lot of the issues with interop at all! Rust has great support for serialization/deserialization, gRPC, and other IPC/RPC technologies which can facilitate this.</p>
<p>If you need Rust and foreign code in the same process, then they should be used in separate 'components' of your design. Do not attempt to have Rust and foreign code interoperate in a fine-grained way within a single component. If you are migrating from another language to Rust, plan the migration on a per-component rather than a per-file basis. It is worth putting some up-front effort into designing the API of these components and the language boundary. As well as the usual API design issues, making the API coarse-grained (i.e., avoiding many calls), using simple datatypes (the more C-like, the better) with simple invariants, and avoiding bidirectional interaction will make FFI issues simpler.</p>
<p>Using a generic FFI option, such as COM/WinRT, is a good option if components can be separate to this extent. You will still have to consider safety issues, but the mechanical issues of corresponding types, etc., are much easier. The windows-rs crate offers good support for COM and WinRT.</p>
<p>In terms of dependencies, Rust code can be either upstream (e.g., R -&gt; C) or downstream (C -&gt; R) of foreign code (it is possible to have many layers of dependencies, e.g., C -&gt; R -&gt; C but each dependency can be considered separately). It is possible to have Rust code embedded in a foreign library and thus have a bidirectional dependency, however, you should avoid this! It is difficult to manage and build the code, and makes interop error-prone.</p>
<p>In other words, you can think of interoperating code as either exposing a Rust API to C code (or other languages which interoperate with a C ABI), or as exposing a C API to Rust code. The former is usually encountered when writing a Rust component which can be used from other languages, the latter when new Rust code must interoperate with legacy code.</p>
<h3 id="using-rust-code-from-c"><a class="header" href="#using-rust-code-from-c">Using Rust code from C</a></h3>
<p>When designing a Rust library to be used from other languages, the design depends on whether the library is only designed to be used from other languages or if it is meant to be used from Rust code too (and in this case, whether the usage from Rust or from other languages is primary). If the Rust code will only be used from other languages, then design a crate with no public items other than <code>extern</code> ones which are C-compatible. If the Rust code must be used from both Rust and other languages, then it is usually better to have a pure Rust crate and a second wrapper crate which provides the C API. If the primary consumer will be Rust code, then design the Rust crate to have a Rust-idiomatic API; the wrapper crate may need to do considerable work to project a C API. If the primary consumer will be other languages, then design the API of the Rust crate to be C-idiomatic (but expressed in Rust), and the wrapper crate can be a thin wrapper (perhaps entirely auto-generated by CBindgen).</p>
<h3 id="using-c-code-from-rust"><a class="header" href="#using-c-code-from-rust">Using C code from Rust</a></h3>
<p>When wrapping a foreign library for use in Rust, consider writing a first layer in C (especially if the legacy code is C++) with an API better suited for interacting with Rust. Then have a crate which is only bindings of C code into Rust (either hand-written or auto-generated). The next layer is a crate which only has the functionality of the foreign library (i.e., no client logic), but presented in a Rust-idiomatic way. The bindings crate will be all <code>unsafe</code>, the idiomatic crate should aim to have a 100% safe API. Clients should only use the idiomatic crate and never use the bindings crate (some advanced usages may require using the bindings in unanticipated ways, however these clients should create safe abstractions of their own rather than use the bindings directly). If following this pattern, it is common to give the idiomatic Rust crate the same name as the foreign library, and the bindings library the same name with the -sys suffix, e.g., <code>foo</code> and <code>foo-sys</code>. (On the topic of naming, it is idiomatic to always avoid using an <code>-rs</code> suffix on any Rust crate: it is nearly always obvious from context that the crate is a Rust library, so <code>-rs</code> usually adds nothing).</p>
<pre><code>------------------------
     C/C++ library          libfoo
------------------------
       C wrapper            libfoo-ffi
------------------------
 Rust bindings (unsafe)     foo-sys
------------------------
Rust wrapper (idiomatic)    foo
------------------------
      Rust users
------------------------
</code></pre>
<h2 id="building"><a class="header" href="#building">Building</a></h2>
<p>If you have a mostly Rust project with some foreign libraries, you should use Cargo. If you have a project with only a small amount of Rust, then you will probably want to use the existing build system and will need to find a way to integrate the Rust build into it. Integrating Cargo and rustc with other build systems is a big topic, and this section will only be a brief summary.</p>
<p>To build foreign libraries inside a Cargo project, the usual approach is to orchestrate the foreign builds from <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">build.rs</a>. The <a href="https://crates.io/crates/cc">CC</a> crate is often used to build C/C++/ASM from a build script.</p>
<p>To build Rust code from a different build system you have several options, depending on your project's constraints. The simplest approach is to have the build system just call <code>cargo build</code>, however this means the build system treats the whole Rust build as a black box, that Cargo will need network access (or you can vendor the crates, see below), and if you have multiple Rust crates they will not share dependencies (unless they can all be built with a single Cargo invocation).</p>
<p>Another approach is to use <a href="https://doc.rust-lang.org/cargo/commands/cargo-vendor.html"><code>cargo vendor</code></a> to compute and download dependencies and keep these checked-in to version control ('vendored'). Building the Rust sub-project can be handled by the build system which will call rustc directly.</p>
<p>There are also more sophisticated, part-automated approaches available for some build systems. E.g., <a href="https://github.com/google/cargo-raze">cargo-raze</a> for Bazel or <a href="https://github.com/facebookincubator/reindeer">reindeer</a> for Buck.</p>
<p>You will probably want to build a <a href="https://doc.rust-lang.org/reference/linkage.html">cdylib</a> rather than the default rlib or dylib. That is because a cdylib uses the C ABI rather than Rust's unstable ABI. </p>
<p>It is common to end up with multiple disjoint components in each language within a single project. You probably don't want to 'split' the project by language (e.g., having a single Cargo project for all Rust code or having a high-level 'rust' directory). It is usually better to have independent builds for each component (i.e., one Cargo project for each Rust component and separate sub-projects for non-Rust components), and the main library/application build system composes the output of each sub-project.</p>
<p>As well as promoting more componentized design, this has practical benefits for Cargo feature propagation, dependency versioning, etc. However, it might make builds slower because there is less sharing of artefacts.</p>
<h2 id="bindings-and-types"><a class="header" href="#bindings-and-types">Bindings and types</a></h2>
<p>Bindings between Rust and foreign functions can either be hand-written or auto-generated. To generate bindings for C/C++ functions in Rust, use <a href="https://github.com/rust-lang/rust-bindgen">bindgen</a>. To generate bindings for Rust functions in C, use <a href="https://github.com/eqrion/cbindgen">cbindgen</a>. These tools can either be called from build.rs to create bindings on the fly, or used from the command line to generate bindings which can be adjusted and checked in to version control (the latter being a good compromise between generated and hand-written bindings).</p>
<p>Choosing hand-written or generated bindings is a trade-off. Automatically generated bindings are less work, stay up to date if the foreign code changes, and are more likely to be bug-free. Getting all the types right in bindings is sometimes subtle and tricky, and is not checked at compile time. Furthermore, some bindings can be target-dependent, so any approach which does not generate bindings with knowledge of the target platform has an increased likelihood of bugs.</p>
<p>On the other hand, hand-written bindings can sometimes be higher quality since the programmer has more knowledge of how the code is used, and binding-generating tools have limitations including around modularity (bindgen does not expect to run multiple times in a single project and therefore types which are logically the same will have multiple definitions which can lead to incompatibility).</p>
<p>We recommend using auto-generated bindings where possible. In particular, wrapping generated bindings with idiomatic Rust code is less fragile in the face of change or consistency issues than trying to write better bindings by hand.</p>
<p>Another approach if you really need custom bindings but have significant amount of code (or target-dependence) is to write your own bindings generators, either from scratch or by forking bindgen. This is more reasonable if you have some source of truth for the generated bindings other than C headers.</p>
<p>Whether bindings are hand-written or auto-generated, they must follow the same rules and idioms.</p>
<p>To call a <a href="https://doc.rust-lang.org/nomicon/ffi.html#calling-foreign-functions">foreign function from Rust</a>, it must be redeclared in a Rust module inside an <code>extern</code> block, e.g.:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(name = &quot;some_c_library&quot;)]
extern {
    fn callable_from_rust();
} 
<span class="boring">}
</span></code></pre></pre>
<p>To expose a Rust function to C code, declare it using the <a href="https://doc.rust-lang.org/reference/items/functions.html#extern-function-qualifier"><code>extern</code> keyword in its signature</a>. Any extern function should use the <code>#[no_mangle]</code> attribute to prevent name mangling, e.g.:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern fn callable_from_c() {
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>For primitive types (e.g., <code>long</code>, <code>double</code>) in these bindings, it is recommended to use the type aliases in the <a href="https://crates.io/crates/libc">libc</a> crate which match with C types. Libc also provides Rust versions of non-primitive types used in the C standard library; <a href="https://crates.io/crates/windows-rs">windows-rs</a> provides similar Windows-specific types.</p>
<p>Rust integers, floats, and booleans correspond with C equivalents and no conversion is required (see the aliases in libc for the correspondence between Rust and C types). Note that booleans in Rust must be either <code>0</code> or <code>1</code>, technically this is true in C/C++ too, however, it is common to use integers as booleans and to treat any non-zero value as true. You must ensure that a value is <code>0</code> or <code>1</code> before treating it as a Rust <code>bool</code>.</p>
<p>Rust raw pointers can correspond with C pointers. Use <a href="https://doc.rust-lang.org/stable/std/ffi/enum.c_void.html"><code>std::ffi::c_void</code></a> for <code>void</code> pointers. 'Opaque pointers' (where the pointee is only used in one language) can be handled trivially. If the pointee is to be accessed from multiple languages, then you must consider the pointee type for compatibility.</p>
<p>Treating objects as opaque is a common idiom for interop (and <a href="https://en.cppreference.com/w/cpp/language/pimpl">in C++</a>). For foreign types which should be opaque in Rust, you can use a struct with a single private field which is a zero-sized array (there used to be advice to use a zero-variant enum for opaque types but that is no longer recommended because it can lead to UB in some circumstances (because the compiler might assume a zero variant enum can never be created)). If you must pass an opaque struct by value, then you can make it the correct size (though this is obviously fragile). For Rust types which should be opaque in C, you can declare but not define the type. Both bindgen and cxx have built-in support for such opaque types.</p>
<p>Slices in Rust combine a pointer to data with the length of the slice into a wide pointer. These components can be passed to C for use as an array without any deep conversion. The slice must be disassembled when passed to C, and if an array is passed to Rust, then it can be re-assembled (see <a href="http://jakegoulding.com/rust-ffi-omnibus/slice_arguments/">the FFI omnibus</a> for details).</p>
<p>User-defined Rust types (structs, unions, and some enums) can be passed to foreign code and accessed there. You will need to declare structs and <a href="https://doc.rust-lang.org/reference/items/unions.html">unions</a> using <a href="https://doc.rust-lang.org/nomicon/other-reprs.html#reprc"><code>#[repr(C)]</code></a> (or rarely <code>#[repr(packed)]</code>), and ensure that all field types are C-compatible.</p>
<p>Only enums with no fields are C-compatible. You must specify the <a href="https://doc.rust-lang.org/nomicon/other-reprs.html#repru-repri">type of the determinant</a> and may want to specify the values of variants.</p>
<p>Other Rust types should not be passed to C, unless they will be treated completely opaquely. This includes zero-sized types, trait objects, other dynamically sized types (such as slices and strings without being adapted), tuples, and enums with fields (technically it is possible to share enums with fields which are <code>#[repr(C)]</code> but the correspondence between C and Rust types is complicated and we advise against it).</p>
<p>Consider the traits derived for types which will cross the FFI boundary (e.g., <code>Send</code>, <code>Sync</code>, <code>Copy</code>, <code>Clone</code>, <code>Default</code>, <code>Debug</code>). These can affect the semantics of the types in Rust (e.g., <code>Copy</code>), can affect how tools generate bindings, and/or affect the ways in which types must be handled in foreign code (e.g, if a type does not implement <code>Send</code> then it must not be moved between threads even in foreign code where this is not enforced by the compiler). If you're using a tool to generate bindings, the documentation for that tool should have more details.</p>
<h3 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h3>
<p>It is never OK to unwind across the FFI boundary, therefore neither Rust panics nor C++ exceptions can be used. Rust's <code>Result</code> type is an enum with fields and therefore cannot cross the FFI boundary. This all makes error handling somewhat challenging. I don't think there is a general solution, you basically just have to do whatever fits best with the C code and convert that error handling to idiomatic Rust error handling as part of the wrapping of the FFI bindings into idiomatic Rust (e.g., implement a set of functions and macros to convert a C error code into a Rust <code>Result</code>).</p>
<h2 id="safety"><a class="header" href="#safety">Safety</a></h2>
<p>All foreign code is considered unsafe by Rust. Therefore, working with foreign code is intimately related to working with unsafe code. If you are writing code which involves FFI you should have a good understanding of unsafe code in Rust. That is a big topic! Too big to cover in depth here, but I'll try and cover some of the basics and some of the interop-specific parts. See the resources below - the <a href="https://doc.rust-lang.org/nomicon">Nomicon</a> is probably the best place to start.</p>
<p>Unsafe code does not give the programmer permission to violate Rust's safety invariants. Unsafe code <em>requires</em> the programmer to uphold those invariants rather than relying on the compiler to check them. Safety is not a local property, it is possible to do things in unsafe code which cause runtime errors in safe code. Safety is often subtle and unintuitive to reason about, see this <a href="https://www.ralfj.de/blog/2020/07/15/unused-data.html">blog post</a> for some examples. The programmer must therefore carefully consider safety for any data which passes the FFI boundary, including how it is accessed in foreign code.</p>
<p>When a function is marked <code>unsafe</code> then it's whole body is treated as unsafe code, however, there is a big difference between an <code>unsafe</code> function and a safe function with an <code>unsafe</code> block - the former is unsafe to call, the latter is safe to call. You should make a function <code>unsafe</code> if the caller must help maintain safety invariants in any way. Making a function safe (with or without internal unsafety) indicates that the library and compiler will ensure safety with no requirements on the caller.</p>
<p>Safety invariants must be enforced at the boundary between safe and unsafe code. When interoperating with foreign code that means that safety invariants must be established as part of the FFI boundary. There are several techniques for helping to ensure safety at the boundary:</p>
<ul>
<li>runtime assertions (e.g., asserting that a pointer is non-null),</li>
<li>types (both Rust and foreign types can encode information which can help ensure invariants),</li>
<li>documentation (clearly documenting safety invariants makes them easier to understand and maintain).</li>
</ul>
<p>Ultimately, we rely on invariants being upheld in foreign code which the Rust compiler cannot check. This is mostly up to the programmer, but can be helped with the above techniques.</p>
<p>Safety in the context of unsafe Rust specifically means memory safety. This can be divided into a few areas which might feel disjoint:</p>
<h3 id="uniqueness-and-mutability-invariants-around-pointers"><a class="header" href="#uniqueness-and-mutability-invariants-around-pointers">Uniqueness and mutability invariants around pointers</a></h3>
<p>Rust's key invariant for ensuring memory safety is that all values must be immutable or unique. This property can be ensured statically or dynamically, but must always be upheld. Even in foreign code, this invariant must be respected, at least as far as it is observable to Rust code. I.e., if Rust code has a reference to a value, then foreign code must not mutate that value unless it can be guaranteed that the value cannot be read by the Rust code.</p>
<h3 id="pointer-validity-invariants"><a class="header" href="#pointer-validity-invariants">Pointer validity invariants</a></h3>
<p>If a raw pointer may be dereferenced in Rust code or converted to a safe reference, then it must be <a href="https://doc.rust-lang.org/nightly/std/ptr/index.html">valid</a>. Since it is usually too late to ensure validity at the point of dereference/conversion, the validity requirement must be well-documented at all points where the pointer is passed, in particular at any FFI boundary. Some aspects of validity can be checked with assertions and the FFI boundary is usually the right place to do that.</p>
<p>Pointer validity includes:</p>
<ul>
<li>pointers must be non-null,</li>
<li>pointers must point to initialised data which has not been deallocated,</li>
<li>pointers must point to well-aligned data,</li>
<li>if the size of a value derived from the pointer's type (including any padding) is n bytes, then the pointer must point to at least n bytes from a single allocated object.</li>
</ul>
<h3 id="thread-safety-invariants"><a class="header" href="#thread-safety-invariants">Thread safety invariants</a></h3>
<p>You must ensure that data which is not <code>Send</code> is not passed between threads and data which is not <code>Sync</code> is not shared between threads, even in foreign code. Furthermore, if dealing with multi-threaded code, the uniqueness and mutability invariant will be especially difficult to uphold. Therefore, it is easiest if Rust data is always kept on a single thread in foreign code.</p>
<h3 id="panics"><a class="header" href="#panics">Panics</a></h3>
<p>Stack unwinding due to Rust panics, C++ exceptions, or any other cause, must never cross the FFI boundary. On the Rust side, you can use <a href="https://doc.rust-lang.org/std/panic/fn.catch_unwind.html"><code>catch_unwind</code></a> to help with this. Note that when catching panics, exceptions etc., you must ensure that no data is left in an inconsistent state. That is often impossible to achieve and aborting the thread or process is the only reasonable behaviour.</p>
<h3 id="derived-safety-invariants"><a class="header" href="#derived-safety-invariants">Derived safety invariants</a></h3>
<p>Many types have their own invariants required in order to preserve safety. These are usually not exposed to the user, except in <code>unsafe</code> functions where some requirements on the caller should be documented. All such requirements must be satisfied even if the function is called from foreign code. In addition foreign code may be able to create objects in ways which are impossible in Rust (e.g., by deserialization or casting from raw bytes). In these cases, you must ensure all invariants are properly established (this can be difficult since if these invariants are not user-facing in Rust code they may be poorly documented).</p>
<p>A good example of a 'derived' invariant is utf-8 validity. Rust strings must always be valid utf-8 and this is relied upon to ensure memory safety, even though utf-8 validity is not directly a memory safety issue. Whenever you create a Rust string, you must ensure it is valid utf-8 (see the <a href="https://doc.rust-lang.org/stable/std/string/struct.String.html">String docs</a> for details).</p>
<h2 id="memory-management"><a class="header" href="#memory-management">Memory management</a></h2>
<p>There are several aspects of the object lifecycle to consider: deallocating memory, calling destructors, and ensuring expected lifetimes of objects. In Rust the object lifecycle is closely tied to ownership, so we discuss these aspects in terms of ownership. The tl;dr is that keeping ownership of an object (in terms of program design, not necessarily Rust types) in the language in which it was created is usually the best strategy.</p>
<p>Independent of FFI, memory must usually be deallocated by the same allocator which allocated it. Without some rather specialist effort, the allocators used from different languages will be different. Therefore, you must deallocate memory in the same language where it was allocated. If objects are passed across the FFI boundary by pointer, and that pointer is morally borrowed, then there is no tidying-up required. If ownership is transferred, then the programmer must keep around a callback to the creating language to deallocate the memory, or pass the object back for destruction.</p>
<p>Note that destructors will not be called automatically in the foreign language. So these must be called explicitly when the object is destroyed.</p>
<p>A common pattern for this is that the foreign language has a wrapper type who's destructor handles calling the creating language's destructor explicitly and calls back into that language to deallocate memory (this pattern works to or from Rust).</p>
<p>If objects are passed by value rather than by pointer, then they must implement <code>Copy</code> in Rust. Otherwise they will be copied in the foreign language where Rust assumes they will be moved. Note that objects cannot implement both <code>Drop</code> and <code>Copy</code> so you will not need to worry about calling <code>drop</code> in this case.</p>
<p>Any object accessed from Rust (whether the object was created in Rust code or not) must abide by Rust's ownership and borrowing discipline. With regards to lifecycle events, this means that destroying a borrowed pointer must not destroy the underlying object, that an owned object must not be destroyed if there are any borrowed pointers to it (or owning pointers to it if there is multiple ownership, e.g., via <code>Rc</code>), and that an object should be fully destroyed when it goes out of scope if held by value, or when all owning pointers are destroyed if it is held by pointer. Regarding FFI, this generally requires that documentation is clear about whether raw pointers/C pointers are morally owning or borrowed (and that this is tracked through foreign code), and that the FFI boundary should not transfer ownership when there are extant borrowed pointers to the object.</p>
<h2 id="c"><a class="header" href="#c">C++</a></h2>
<p>Interoperating with C++ is much more complicated than interoperating with C. If you follow the advice above to only interoperate at component boundaries and you design your component APIs in a conservative, C-like way (possibly by having a C-like library wrap the C++ one), then Rust/C++ interop can be fine - it is even quite well supported by Bindgen. If you must have more fine-grained interop, then things get interesting.</p>
<p>If you can (and plain bindgen is not enough), we recommend using <a href="https://cxx.rs/">cxx</a> to generate a bridge layer and bindings between Rust and C++ code. <a href="https://github.com/google/autocxx">autocxx</a> is an extension if you prefer auto-generated bindings.</p>
<p>Quite a lot of C++ features work well across FFI, see the <a href="https://rust-lang.github.io/rust-bindgen/cpp.html">bindgen docs</a> for details. There are more links to docs on C++ interop below. It can be a bit hit and miss figuring out exactly what works and what doesn't and unfortunately some issues are not caught at compile time.</p>
<div style="break-before: page; page-break-before: always;"></div><p>TODO exec summary</p>
<h1 id="estimating-the-complexity-of-interop"><a class="header" href="#estimating-the-complexity-of-interop">Estimating the complexity of interop</a></h1>
<p>This chapter aims to help you estimate the costs and risks of integrating Rust into an existing mixed-language project. You'll be able to make a better judgement if you read the rest of the documentation and can therefore understand the issues more deeply. Hopefully this chapter can give you a framework for estimation, and if you don't have time to dive deeper, then at least give you a rough idea.</p>
<p>This chapter does not aim to help with the question of whether Rust is a good choice for a project, only to cover the integration component of that choice.</p>
<h2 id="rewriting-a-project-or-adding-to-a-project"><a class="header" href="#rewriting-a-project-or-adding-to-a-project">Rewriting a project or adding to a project?</a></h2>
<p>Integrating Rust with a foreign language typically happens in one of two scenarios: adding Rust to an existing non-Rust project, or converting an existing non-Rust project into a Rust one. The difference being that in the second case, the goal is for the entire project (or most of it) to be Rust, whereas in the first case, only a small portion may ever be Rust.</p>
<p>When adding to a project, the parameters which affect integration are usually well-known. Typically the project will not change much at the same time as adding a Rust portion. So there is not much opportunity to change the cost or risk of adding Rust. In this case the more that the Rust portion is self-contained, the better. Adding a little Rust all over the project is a much riskier undertaking than adding single Rust component with a limited interface.</p>
<p>When converting a project to Rust, as good software engineers, we want to do the conversion as incrementally and iteratively as possible. However, this has the requirement that existing foreign code integrates with new Rust code. The more incremental the conversion, the more fine-grained the integration must be and this will make interop more difficult. From the perspective of integration, the best-case scenario is to do a clean rewrite with zero temporary interop (taking advantage of existing test suites, documentation, requirements, etc. but not doing an incremental rewrite). Where this is not possible, doing a rewrite one component at a time, rather than one function, data structure, or file at a time is highly desirable. In my opinion, the former is likely to be successful (although depending on many other factors), but the latter is doomed to failure in nearly all circumstances.</p>
<h2 id="languages"><a class="header" href="#languages">Languages</a></h2>
<p>As a general rule, integrating Rust with C is the easiest scenario. If the foreign language is C++, then things will be harder, but how hard will depend on the style used in the C++ code and the nature of the project (see below for more discussion). The more C-like the code (and especially the interface with Rust), the easier integration will be.</p>
<p>If the foreign language is a managed language (C#, Java, Python, Ruby, etc.) then integration is possible but will have very different characteristics to integrating with native languages. The costs and risks will be specific to the foreign language (some have much better support for Rust integration than others). These docs should be expanded in the future to better cover this scenario.</p>
<h2 id="tooling"><a class="header" href="#tooling">Tooling</a></h2>
<h3 id="build-and-dependency-management"><a class="header" href="#build-and-dependency-management">Build and dependency management</a></h3>
<p>Rust projects are natively built with Cargo. Cargo is a build system and package manager. These areas of functionality are tightly integrated and Cargo does not integrate easily with other build systems. Using rustc directly is a rare path and is thus unpleasant and poorly supported.</p>
<p>One straightforward scenario is where a Rust crate is not depended on by any foreign code (i.e., it is a leaf node in the dependency graph). In this case all foreign code is upstream of Rust code and build system integration is fairly straightforward. Similarly, if a Rust crate does not depend on any foreign code (at least outside of the standard library), then the Rust code can be compiled in relative isolation and again build system integration is simpler. Having multiple Rust components in one or other of these situations is also fairly straightforward, as long as they don't depend on each other and you don't mind some duplication of compilation where there are shared dependencies (i.e., the extra time and potential version incompatibility).</p>
<p>More overlap and constraints between components makes build system integration more complicated. If you will require multiple 'layers' of dependency between Rust and foreign code, and require the Rust components to play nicely with respect to Cargo's version resolution, then integration will be complicated and require effort (how much depends on which build system you're integrating with, see below, and the details of the project).</p>
<p>The most common pattern for build system integration, is to run Cargo's package management functionality offline. Rust dependency sources can then be stored in-tree and when building, they only need to be compiled (which, with some setup, does not require Cargo). Tooling exists to help with this (cargo vendor). The downside of this approach is that updating dependencies is a manual step. It also makes the source tree much larger and the VC history a little less clear. If your project can accommodate this pattern, then build system integration will be much, much easier than if it can't.</p>
<p>Some build systems have existing tools for Rust/Cargo integration (or are a well-troden path with good docs). If you are using these, integration will be easier:</p>
<ul>
<li>Buck</li>
<li>Bazel</li>
<li>make/cmake?</li>
<li>TODO any more? Links and descriptions for above</li>
</ul>
<p>Linking Rust binaries with other native binaries is generally straightforward because Rust follows native standards for each platform. Integration may be more difficult if you require dynamic linking since Rust has a bias towards static linking, and although dynamic linking is supported, it is a less common path. Link-time optimisation (and PGO) will work with Rust, including across languages (which means that there is not even an optimisation penalty for mixing Rust with C/C++ in many cases), however, Rust uses LLVM for its backend, and so LTO will only work within the LLVM ecosystem. TODO is this true? Is it possible to LTO without LLVM?</p>
<h3 id="ci"><a class="header" href="#ci">CI</a></h3>
<p>TODO</p>
<h3 id="static-analysis-and-related-tooling"><a class="header" href="#static-analysis-and-related-tooling">Static analysis and related tooling</a></h3>
<p>elf binaries, debuginfo, llvm ecosystem
valgrind seems to work quite well
relying on gcc or VS means hard work
analyses which rely on optimisation might have issues
anything which relies on source code or AST will not work
Rust has fairly good tooling (rustfmt, clippy, miri, etc) often but not always works in the presence of foreign code
TODO - more specific stuff for widely used tools</p>
<h3 id="debugging-profiling-and-other-developer-tools"><a class="header" href="#debugging-profiling-and-other-developer-tools">Debugging, profiling, and other developer tools</a></h3>
<p>debugging and profiling generally work across language boundaries, IDEs generally don't (although usually you can get pretty good independent coverage of the different languages)
only likely to be problems if tooling is tied to gcc or VS ecosystems</p>
<h2 id="nature-of-the-project"><a class="header" href="#nature-of-the-project">Nature of the project</a></h2>
<p>This section covers some topics which are about various aspects of a projects architecture, design, and code style. These are mostly not 'black and white' topics, but rather have a bunch of nuance and subtlety. These are also mostly things where you can make choices early in our adoption of Rust which will make integration <em>a lot</em> easier.</p>
<p>If your project has a microservices-style architecture with components running on their own nodes or in their own processes and you can keep Rust in entirely new components, then integration should be easy (relatively). Rust has good support for many forms of IPC, networking, serialization/deserialization, etc. You may still have integration issues with build or CI which need considering, but for the code itself, you are in a best-case scenario.</p>
<p>Only slightly worse than the previous situation is if you have a monolithic application, but you can keep the new Rust code in a separate process. The integration will still be easy, but you're likely to have more design issues.</p>
<p>Assuming Rust code must be in the same process as existing foreign code, the more modular the architecture, the easier integration will be. Most challenges with interop are design challenges where it is difficult to ensure modularity (and the specific kind of modularity which make interop easier) in the face of requirements which favour tight integration of components. Keeping Rust to modules/components with strong, well-designed APIs will make interop easier.</p>
<p>More specifically, the kinds of modularity that benefit interop are:</p>
<ul>
<li>TODO</li>
</ul>
<p>And a few things which don't help much:</p>
<ul>
<li>keeping data private and using accessor methods (unless those accessor methods enforce invariants of the data),</li>
<li>TODO</li>
</ul>
<p>Rust interop primarily uses the C ABI, but many C++ features work across the language boundary too. There are both C and C++ features which can make interop more or less difficult. Difficult can mean requiring more tooling, more conversion of data types at the language boundary, more invariants which must be enforced by the programmer, language features which must be manually emulated rather than implemented by the compiler, riskier code (i.e., bugs are more likely and/or harder to see), or that direct sharing of data or calling of functions is not possible.</p>
<p>The following features work without any runtime conversion and don't require tooling (though using bindgen may make things easier):</p>
<ul>
<li>primitive numeric and boolean data,</li>
<li>structs and field access,</li>
<li>simple (C-like) enums,</li>
<li>function calls with C ABI,</li>
<li>opaque pointers (i.e., pointers which are never dereferenced),</li>
</ul>
<p>The following features require either manual emulation in Rust or some encoding:</p>
<p>TODO, for each, discuss the implications</p>
<ul>
<li>lifecycles methods (constructors, copy constructors, destructors, etc.),</li>
<li>method calls,</li>
</ul>
<p>TODO - features, C++ features
enums
inheritance
move semantics
pointer arithmetic, casting, etc
generics, template tomfoolery
Rust features into C/C++ - enums, traits, etc, etc</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-mechanics-of-ffi"><a class="header" href="#the-mechanics-of-ffi">The mechanics of FFI</a></h1>
<p>No runtime, bare metal means low-level interop is free</p>
<p>where the ABI of Rust and foreign lang coincide, interop is free. Where it doesn't we require abstraction layer work
stable and de facto stable Rust ABI</p>
<p>function calls and data must agree</p>
<p>runtime behaviour
async/concurrency
unwinding</p>
<h2 id="declaring-and-defining-functions"><a class="header" href="#declaring-and-defining-functions">Declaring and defining functions</a></h2>
<p>For a function to be called across languages, it must be declared in both languages (but only defined in one) so that both compilers can find it. The two declarations must end up associated with the same definition, and this requires linking object files correctly, see the chapter on <a href="mechanics/TODO">building and linking</a> for details. If declared correctly, calling the function requires no special effort and no runtime overhead (it can even be inlined across languages if using link-time optimisation (LTO)).</p>
<p>TODO dyn linking
TODO calling is unsafe</p>
<p>Global variables can also be accessed across the FFI boundary, see the <a href="mechanics/TODO">reference</a> chapter.</p>
<h3 id="function-defined-in-rust"><a class="header" href="#function-defined-in-rust">Function defined in Rust</a></h3>
<p>This section will cover defining a Rust function which can be called from a foreign language.</p>
<p>For a Rust function to be callable from a foreign language you must use the <code>extern</code> keyword to specify the ABI. <code>&quot;C&quot;</code> is the default and most common option, see the reference for a full list. If the function should be name-able from outside Rust, you should use the <code>#[no_mangle]</code> attribute to prevent name mangling. You'll usually need this, unless the function is only used via a function pointer.</p>
<p>E.g.,</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn foo() -&gt; i32 {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>You'll need to declare the function in foreign code to use it. In C/C++ this will look the same as declaring a C function (usually declared in headers as required). E.g.,</p>
<pre><code class="language-C">int foo();
</code></pre>
<h3 id="function-defined-in-cc"><a class="header" href="#function-defined-in-cc">Function defined in C/C++</a></h3>
<p>This section will cover defining a C/C++ function which can be called from Rust.</p>
<p>A function defined in C/C++ will be just a regular function, just don't declare it <code>static</code> (the default is <code>extern</code>, which is what we want).</p>
<p>In Rust the function must be declared. This is done inside an <code>extern block</code>. Functions declared in an <code>extern</code> block may not have bodies, are implicitly unsafe to call, and have a specified ABI (<code>&quot;C&quot;</code> by default). Various attributes control how function definitions are discovered and linked, see the <a href="mechanics/TODO">reference</a>.</p>
<p>E.g.,</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;C&quot; {
    fn foo() -&gt; i32;
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="data"><a class="header" href="#data">Data</a></h2>
<p>When data is passed across the FFI boundary, its type must be known on both sides (i.e., there must be declarations in both languages) and those types must be compatible. Compatibility involves both a type's representation (how it is laid out in memory) and invariants of the type (due to either the language or the type itself). Compatibility is not quite a symmetric relation because while the representations must match, the invariants must be the same or stronger on the callee side than the caller side. Where representations are compatible but invariants are not, the missing invariants can be made requirements for the caller to satisfy. Compatibility is also platform-dependent since different syntactic types may have different representations on different platforms.</p>
<p>Type compatibility is a big topic. We'll summarise here and give a complete description in the <a href="mechanics/TODO">reference</a>.</p>
<p><a href="https://doc.rust-lang.org/stable/std/ffi/index.html">std::ffi</a> defines type aliases for common numeric types which are platform-accurate; <a href="https://crates.io/crates/libc">libc</a> defines a few more aliases for less common types. Using these aliases is usually easier than using Rust types directly.</p>
<p>Primitive types (integers, floating point types, and booleans) are straightforwardly compatible, though the names are different in C and Rust and the correspondence is platform-dependent (using <code>std::ffi</code> in Rust is the easiest solution). Characters are also a primitive type in C and Rust, but have different sizes and encodings in the different languages. C <code>char</code>s are compatible with Rust's <code>i8</code> or <code>u8</code> . A Rust <code>char</code> is compatible with a C <code>unsigned int</code> or <code>unsigned long</code>, however, a Rust <code>char</code> must always be a valid <a href="https://www.unicode.org/glossary/#unicode_scalar_value">Unicode scalar value</a>, this requirement must be satisfied in the C code before the data has the Rust <code>char</code> type.</p>
<p>If <code>T_rust</code> and <code>T_c</code> correspond, then <code>*const T_rust</code> and <code>const T_c*</code> correspond, and <code>*mut T_rust</code> and <code>T_c*</code> correspond. When calling foreign functions from Rust code, you can use <code>&amp;mut T_rust</code> and <code>&amp;T_rust</code>, respectively in the Rust function declaration (Rust references and raw pointers have the same representation). You can also use <code>Option&lt;&amp;mut T_rust&gt;</code> and <code>Option&lt;&amp;T_rust&gt;</code>, see the discussion on enums, below. You cannot do this in the opposite direction (i.e., use a Rust reference in a Rust function definition and a pointer in the C declaration), since the Rust reference types have more invariants which must be satisfied. (You technically can do this without any compile-time errors and require the additional invariants in the foreign code, however, these invariants are difficult to guarantee and failing to do so will cause undefined behaviour).</p>
<p>TODO ^ the pointees don't have to correspond fully. Box, Rc, etc.</p>
<p>C and Rust structs are compatible if they have corresponding fields and the field types are compatible (and the Rust struct is <code>repr(C)</code>). Sometimes a C struct may have hidden fields (sometimes called an opaque struct). Such types can be represented in Rust as a zero-sized type with a private field and no constructor function (so the type cannot be instantiated), you can include a field with type <code>PhantomData&lt;(*mut u8, PhantomPinned)&gt;</code> to prevent the type implementing the <code>Send</code>, <code>Sync</code>, or <code>Unpin</code> auto-traits. See the <a href="mechanics/TODO">opaque struct pattern</a> for more.</p>
<p>C and Rust unions are compatible if the the Rust union is <code>repr(C)</code> and their fields are compatible. Field compatibility is a bit more complex than for structs: the unions must end up the same size and any pair of fields which are used together must be compatible. It is up to the programmer to ensure compatible usage of the unions.</p>
<p>Rust enums with no embedded data which are <code>repr(C)</code> are compatible with C++ enums if they have the same number of variants, the specified (or implicit) determinant types match, and the values of all variants match. It is possible to loosen these restrictions slightly. It is <em>invalid</em> for an enum to have a value which is not a declared variant. So as long as there is a Rust variant which matches any C++ variant which may be passed across the FFI boundary, the enums are compatible.</p>
<p>Enums which are 'option-like' (i.e., have two variants, one with a single field and one with no embedded data) and where the payload type is a non-null pointer type are compatible with the corresponding (nullable) pointer type in C/C++. E.g., <code>Option&lt;&amp;Foo&gt;</code> is compatible with <code>const Foo*</code> (subject to the restrictions described above for pointer compatibility). Similarly an option-like enum with the <a href="https://doc.rust-lang.org/nightly/std/num/index.html">non-zero numeric types</a> is compatible with the (zero-able) numeric type in C/C++.</p>
<p>Most tuple types are incompatible with C/C++ types because their representation cannot be specified. The exception is the empty tuple, <code>()</code> which is compatible with the <code>void</code> type in C/C++ when passed by pointer.</p>
<p>In general, zero-sized types are incompatible with foreign types.</p>
<p>C strings are pointers to <code>char</code>s and as expected are compatible with <code>*mut u8</code> or <code>*mut i8</code>. Despite their resident module, <code>std::ffi::CStr/CString</code> should not be used directly for FFI because their representations are not guaranteed.</p>
<p>TODO C++ types</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patterns"><a class="header" href="#patterns">Patterns</a></h1>
<h2 id="architectural-patterns"><a class="header" href="#architectural-patterns">Architectural patterns</a></h2>
<ul>
<li>Modular interop - a high level approach for ensuring effective interop</li>
<li><a href="patterns/layered.html">Layered library design</a> - how to structure libraries and crates for interop</li>
<li>-sys crate</li>
<li>Wrap a C library</li>
<li>Serialization</li>
<li>Cross-language ownership</li>
</ul>
<h2 id="design-patterns"><a class="header" href="#design-patterns">Design patterns</a></h2>
<ul>
<li>Foreign dtor</li>
<li>Object-based API (https://rust-unofficial.github.io/patterns/patterns/ffi/export.html)</li>
<li>Rust version of C object</li>
<li>Something about intermediate types like CString/OsString (https://rust-unofficial.github.io/patterns/idioms/ffi/accepting-strings.html, https://rust-unofficial.github.io/patterns/idioms/ffi/passing-strings.html)</li>
<li>Transparent smart pointer</li>
<li>Consolidated wrapper (https://rust-unofficial.github.io/patterns/patterns/ffi/wrappers.html)</li>
<li>Strings (how to actually use them, see strings links above, https://snacky.blog/en/string-ffi-rust.html, https://dev.to/kgrech/7-ways-to-pass-a-string-between-rust-and-c-4iebZ)
)</li>
</ul>
<h2 id="programming-idioms-and-best-practices"><a class="header" href="#programming-idioms-and-best-practices">Programming idioms and best practices</a></h2>
<ul>
<li>Representing Rust errors in C (https://rust-unofficial.github.io/patterns/idioms/ffi/errors.html)</li>
<li>Representing C errors in Rust</li>
</ul>
<h2 id="anti-patterns"><a class="header" href="#anti-patterns">Anti-patterns</a></h2>
<ul>
<li>Disguising pointers as values (unclear, disguises unsafety)</li>
<li>Using C structs directly in Rust (back compat hazards including padding, due to different back compat between C and Rust)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="layered-library-design"><a class="header" href="#layered-library-design">Layered library design</a></h1>
<p>When wrapping a foreign library for use in Rust, consider writing a first layer in C (especially if the legacy code is C++) with an API better suited for interacting with Rust. Then have a crate which is only bindings of C code into Rust (either hand-written or auto-generated). The next layer is a crate which only has the functionality of the foreign library (i.e., no client logic), but presented in a Rust-idiomatic way. The bindings crate will be all <code>unsafe</code>, the idiomatic crate should aim to have a 100% safe API. Clients should only use the idiomatic crate and never use the bindings crate (some advanced usages may require using the bindings in unanticipated ways, however these clients should create safe abstractions of their own rather than use the bindings directly).</p>
<p>If following this pattern, it is common to give the idiomatic Rust crate the same name as the foreign library, and the bindings library that name with the -sys suffix, e.g., <code>foo</code> and <code>foo-sys</code>. (On the topic of naming, it is idiomatic to always avoid using an <code>-rs</code> suffix on any Rust crate: it is nearly always obvious from context that the crate is a Rust library, so <code>-rs</code> usually adds nothing).</p>
<pre><code>------------------------
     C/C++ library          libfoo
------------------------
       C wrapper            libfoo-ffi
------------------------
 Rust bindings (unsafe)     foo-sys
------------------------
Rust wrapper (idiomatic)    foo
------------------------
      Rust users
------------------------
</code></pre>
<p>When making a Rust library available to foreign code, you can adopt a similar strategy. Here, we have an idiomatic Rust crate which can be used directly by Rust users and is idiomatic and mostly safe code. There is then a Rust wrapper which is more C-like and presents an API which is more convenient to use for FFI and includes unsafe functions which make clear the invariants callers must maintain. C bindings reflect this wrapper into the C world. This can be used directly by C code, or can there can be a C/C++ wrapper which is more idiomatic (this is much more useful for C++ rather than C, since it is possible to have an idiomatic C API with the direct bindings, but that is much harder for C++). C/C++ users (again, more likely C++) then use this wrapper library rather than the bindings.</p>
<pre><code>------------------------
 Rust crate (idiomatic)     foo
------------------------
 Rust wrapper (unsafe)      foo-ffi
------------------------
       C bindings           libfoo-ffi
------------------------
C/C++ wrapper (optional)    libfoo
------------------------
      C/C++ users
------------------------
</code></pre>
<p>There are not strong naming conventions in this direction, and the above example names are not great.</p>
<h2 id="tooling-1"><a class="header" href="#tooling-1">Tooling</a></h2>
<p>You can use <a href="patterns/TODO">bindgen</a> to generate the bindings layer (foo-sys in the example). You can use <a href="patterns/TODO">cxx</a> to generate both the C wrapper and the bindings layer, or at least parts of both.</p>
<p>In the other direction, you can use <a href="patterns/TODO">cbindgen</a> to generate C bindings (e.g., libfoo-ffi) or <a href="patterns/TODO">cxx</a> to generate both the Rust wrapper, C bindings, and C++ wrapper (although in this case the layers are not clearly defined).</p>
<h2 id="see-also"><a class="header" href="#see-also">See also</a></h2>
<ul>
<li><a href="patterns/TODO">-sys crate</a> - separating the Rust bindings from the idiomatic Rust wrapper - a component of this pattern,</li>
<li><a href="patterns/TODO">Wrap a C library</a> - the C wrapper layer - a component of this pattern.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<p>This section is designed as a reference and you probably don't want to read it end to end. It is primarily aimed at those implementing and designing tools and low-level libraries, or users who need to do unusual and/or low-level interop work. Hopefully, if you're doing common integration work you mostly won't need this level of detail.</p>
<p>TODO mechanics vs safety
I think this is the same as FFI types vs idiomatic types</p>
<p>TODO semi-opinionated
some stuff is still undecided, but we describe the current state of the art
try to cover different points of view and where there are differences, but not all</p>
<p>TODO assumes C/C++</p>
<ul>
<li><a href="reference/functions.html">Functions and Methods</a></li>
<li>statics and consts - TODO <a href="https://doc.rust-lang.org/reference/abi.html#the-used-attribute"><code>used</code> attribute</a>. Using the <code>no_mangle</code> attribute implicitly implies <code>used</code>. Use <code>extern</code> for external linkage</li>
<li><a href="reference/">FFI types</a></li>
<li><a href="reference/data-types.html">Idiomatic types</a>
<ul>
<li><a href="reference/numerics.html">Numeric types</a></li>
<li><a href="reference/strings.html">Strings</a></li>
<li><a href="reference/TODO">Pointers, references, and arrays</a> void pointers, fat pointers, const, arrays and slices, null/non-null, single allocation, no pointers into middle of an object, ZSTs, pointers to deallocated (e.g., dangling) mem, invalid metadata in wide pointers</li>
<li>structs, tuples, and unions</li>
<li>enums</li>
<li>properties - send, sync, eq, hash, etc.</li>
<li>classes? trait objects?</li>
</ul>
</li>
</ul>
<h2 id="linking"><a class="header" href="#linking">Linking</a></h2>
<p>building C and Rust such that object files can be found, etc.</p>
<p>extern blocks</p>
<p><code>#[link(...)]</code> attribute</p>
<h2 id="safety-and-validity"><a class="header" href="#safety-and-validity">Safety and validity</a></h2>
<p>Rust has several useful safety invariants. These are guaranteed to hold (by the compiler and by authors of unsafe code) in most Rust code, but they may be temporarily broken in code which is marked <code>unsafe</code>. Unsafe code does not permit writing code which is not safe, but rather indicates the author of the code is responsible for safety, rather than the compiler.</p>
<p>Since all foreign code is outside of the remit of the Rust compiler, all foreign code is unsafe and must be called from within an <code>unsafe</code> block or function. When writing an FFI layer, we usually want to present a safe API to Rust code, therefore the FFI layer must establish Rust's safety invariants and the safety invariants of any types in its API.</p>
<p>Precisely where safety invariants must hold is still being decided by the Rust project. The current preferred proposal is that the <em>unsafe boundary</em> is the <em>public API</em> of a <em>module</em> (including its sub-modules). Note that this is not defined in terms of unsafe blocks or functions! In more detail, for any public (i.e., visible from an outside module, not necessarily <code>pub</code>, <code>pub(crate)</code>, <code>pub(super)</code>, etc. would count if there is an enclosing module in the crate) function (or method) of a module, there is a set of safety requirements. For safe functions, this set is empty, for <code>unsafe</code> functions, this set should be documented. If all these requirements are satisfied, then calling the function will never result in a memory safety error occurring. During the function call, safety invariants (both Rust's and the module's) may be violated, but they must be re-established (perhaps relying on the function's safety requirements) by the time the function returns (or unwinds).</p>
<p>Rust also has validity invariants. These must hold in all Rust code both safe and unsafe (otherwise it is <em>undefined behaviour</em>). Validity invariants do not need to hold in foreign code, but must be re-established before control is returned to Rust (i.e., before crossing the FFI boundary). Contrast this with safety invariants which may be violated in foreign code and Rust code but must be re-established before crossing the unsafety boundary.</p>
<p>TODO safety and validity are per type and so establishing invariants might occur when data is reinterpreted.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>TODO passing a pointer and length from C code and using it as an array</p>
<p>C code:</p>
<pre><code class="language-C">void do_thing(char* arr, int c_arr) {}


extern void do_thing_impl(char* arr, int c_arr);
</code></pre>
<p>Rust code:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe fn do_thing_impl(arr: *mut u8, c_arr: usize) {}

fn do_thing_idiomatic(arr: &amp;mut [u8]) {
    // regular Rust code
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-and-methods"><a class="header" href="#functions-and-methods">Functions and Methods</a></h1>
<p>Interoperation of functions (including function-like things such as methods and closures) means calling Rust functions from a foreign language or foreign functions from Rust. This means declaring a function in Rust and defining it in C or vice versa. The definition and declaration must <em>agree</em> or there will be undefined behaviour at runtime. The definition must also be discoverable by code in the other language (this is partly an aspect of linking, described <a href="reference/README.html#Linking">previously</a> and partly an aspect of the function definition). This section describes what it means for function declarations and definitions to agree across languages, and how Rust functions must be defined in order to be discoverable by foreign code.</p>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<h3 id="definition"><a class="header" href="#definition">Definition</a></h3>
<p>TODO</p>
<ul>
<li>visibility</li>
</ul>
<h4 id="extern-blocks"><a class="header" href="#extern-blocks">Extern blocks</a></h4>
<p>TODO https://doc.rust-lang.org/reference/items/external-blocks.html</p>
<p><a href="https://doc.rust-lang.org/reference/items/external-blocks.html#the-link-attribute">link attribute</a>
ABI
implicit unsafe
see also statics</p>
<h4 id="name"><a class="header" href="#name">Name</a></h4>
<p>The names of functions (and other items) are <a href="https://rust-lang.github.io/rfcs/2603-rust-symbol-name-mangling-v0.html">mangled</a> by the compiler by default. Name mangling means that the name of the symbol in the compiled binary is not the same as the name in the source code. Name mangling is not stable, and you should not rely on mangled names being the same between compiler versions.</p>
<p>Use the <a href="https://doc.rust-lang.org/reference/abi.html#the-no_mangle-attribute"><code>no_mangle</code> attribute</a> to prevent name mangling of a function's name. E.g.,</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; foo() {}
<span class="boring">}
</span></code></pre></pre>
<p>If you will call a function from foreign code by name then you must use <code>no_mangle</code> (not doing so may cause linking errors or may cause incorrect runtime behaviour). If you will only call a function via a function pointer, then you don't need to.</p>
<p>Alternatively, you can use the <a href="https://doc.rust-lang.org/reference/abi.html#the-export_name-attribute"><code>export_name</code> attribute</a> to explicitly specify the name to use for the exported symbol. E.g.,</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[export_name = &quot;bar&quot;]
pub extern &quot;C&quot; foo() {}
<span class="boring">}
</span></code></pre></pre>
<p>This function can be called using <code>foo</code> from Rust, and <code>bar</code> from C.</p>
<p>Likewise, by default C++ will mangle function names. This is inconsistent between platforms and compilers, so it is not advisable to use the mangled names (this can be done if absolutely necessary and tools like bindgen and cxx can help with this TODO is this true?). To prevent name mangling, define functions in an <code>extern &quot;C&quot;</code> block.</p>
<p>You can specify which section of the binary the function is placed in using the <a href="https://doc.rust-lang.org/reference/abi.html#the-link_section-attribute"><code>link_section</code> attribute</a>.</p>
<h4 id="calling-convention"><a class="header" href="#calling-convention">Calling convention</a></h4>
<p>The <a href="https://doc.rust-lang.org/reference/items/functions.html#extern-function-qualifier"><code>extern</code></a> keyword is used on function definitions to specify the <a href="https://doc.rust-lang.org/nomicon/ffi.html#foreign-calling-conventions">calling convention</a> (aka the ABI) used to call them (and on extern blocks to define the calling convention used to call the foreign functions declared inside, see above). The syntax is <code>extern &quot;ABI&quot;</code> where <code>ABI</code> is the optional <a href="https://doc.rust-lang.org/reference/items/external-blocks.html#abi">ABI identifier string</a>. E.g.,</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub extern &quot;C&quot; foo() {}
<span class="boring">}
</span></code></pre></pre>
<p>If no ABI identifier is supplied, then <code>C</code> is used. If <code>extern</code> is not used at all, then <code>Rust</code> is used.</p>
<p>The calling convention used in the declaration and definition of functions must match. This is likely to entail a somewhat complex interaction of defaults across different platforms and languages, and attributes in different languages. If you have control of both sides of the FFI, then making both <code>extern &quot;C&quot;</code> (either explicitly or by default) is probably the easiest option. You'll need to use other options if you want to match a calling convention in a library which cannot be changed.</p>
<p>The platform independent ABI identifier strings are:</p>
<ul>
<li><code>Rust</code>: Rust's ABI; this is unstable and should not be used for FFI code,</li>
<li><code>C</code>: the default C calling convention,</li>
<li><code>system</code>: the platform default calling convention for calling 'system functions'. Usually the same as extern &quot;C&quot;, except on Win32, in which case it's &quot;stdcall&quot;.</li>
</ul>
<p>The platform-specific ABI identifier strings are:</p>
<ul>
<li><code>cdecl</code>: for x86_32 C code,</li>
<li><code>stdcall</code>: for the Win32 API on x86_32,</li>
<li><code>win64</code>: for C code on x86_64 Windows,</li>
<li><code>sysv64</code>: for C code on non-Windows x86_64,</li>
<li><code>aapcs</code>: for ARM,</li>
<li><code>fastcall</code>: corresponds to MSVC's <code>__fastcall</code> and GCC and clang's <code>__attribute__((fastcall))</code>,</li>
<li><code>vectorcall</code>: corresponds to MSVC's <code>__vectorcall</code> and clang's <code>__attribute__((vectorcall))</code>.</li>
</ul>
<p>You might also come across <code>rust-intrinsic</code>, <code>rust-call</code>, and <code>platform-intrinsic</code>. These are used by the compiler and standard library, but you shouldn't use them in user code.</p>
<p>There also exist <code>-unwind</code> versions of the ABI identifier strings, e.g., <code>C-unwind</code>. These are all <a href="https://github.com/rust-lang/rust/issues/74990">unstable</a>, see the section below on unwinding for more details.</p>
<p>TODO <code>thiscall</code> is <a href="https://github.com/rust-lang/rust/issues/42202">unstable</a>, see discussion on methods</p>
<h4 id="cc-linkage"><a class="header" href="#cc-linkage">C/C++ linkage</a></h4>
<p>C/C++ functions must have external linkage (this is the default, i.e., functions may not be marked <code>static</code>).</p>
<h4 id="signature"><a class="header" href="#signature">Signature</a></h4>
<p>The types of all arguments in the function and its return type as written in the declaration and definition must <em>agree</em>. For more on type agreement, see the sections on <a href="reference/TODO">data types</a>. The names of arguments do not need to match. In Rust declarations of foreign functions, <code>_</code> may be used instead of an argument name. No other patterns may be used in arguments. Patterns may be used instead of names in the usual way for Rust functions which are exported; the foreign declarations should use a name instead of a pattern.</p>
<p>The number of arguments in definition and declaration must match, including variadic arguments. Declarations (but not definitions) in Rust may be <a href="https://doc.rust-lang.org/reference/items/external-blocks.html#variadic-functions">variadic</a> (to match variadic functions defined in C). E.g.,</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;C&quot; {
    fn foo(format: *const u8, args: ...);
}
<span class="boring">}
</span></code></pre></pre>
<p>If a function diverges, then in Rust it should have the <code>!</code> return type. In C/C++ the function should have a 'no return' attribute (<code>__attribute__((noreturn))</code>, <code>[[noreturn]]</code>, <code>[[__noreturn__]]</code>, <code>[[_Noreturn]]</code>, etc. depending on the language, version, and compiler).</p>
<p>TODO what if sigs don't agree?</p>
<p>If the return type must be used, then the Rust function should have the <code>#[must_use]</code> attribute and the C/C++ function the <code>__attribute__((warn_unused_result))</code> attribute. TODO [[nodiscard]] on ctors. Getting this wrong will lead to missing warnings which may in turn lead to runtime errors.</p>
<h3 id="function-calls"><a class="header" href="#function-calls">Function calls</a></h3>
<p>TODO</p>
<p>calling convention (should work)
calling variadics (just works)
see also data
unsafe</p>
<h3 id="const-functions"><a class="header" href="#const-functions">const functions</a></h3>
<p>TODO</p>
<h2 id="unwinding"><a class="header" href="#unwinding">Unwinding</a></h2>
<p>TODO</p>
<p>TODO -unwind ABIs</p>
<h2 id="exceptions"><a class="header" href="#exceptions">Exceptions</a></h2>
<p>TODO</p>
<h2 id="closures"><a class="header" href="#closures">Closures</a></h2>
<p>TODO</p>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p>TODO</p>
<ul>
<li>Virtual/static dispatch</li>
<li>ctors</li>
<li>dtors</li>
<li>operator overloading</li>
</ul>
<h2 id="other"><a class="header" href="#other">Other</a></h2>
<p>TODO</p>
<ul>
<li>async</li>
<li>generators</li>
<li>templates/generics</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-types"><a class="header" href="#data-types">Data Types</a></h1>
<p>Data in both Rust and C/C++ is just ones and zeros in the computer's memory. These ones and zeros are independent of the language which generated them and there is no intrinsic sense of 'compatibility'. However, when data is used, the compiler must have semantics for those ones and zeros which in Rust, C, and C++ is determined by the types of the data. When data is passed across the FFI boundary, two compilers are involved and each must have a type defined in its own language with which to understand the data. For this to produce correct results, corresponding types in the two languages must <em>agree</em>. An abstract example, if a function <code>f</code> is declared in both Rust and C and has a single argument with type <code>T_Rust</code> in Rust and <code>T_C</code> in C, then <code>T_Rust</code> and <code>T_C</code> must agree. If they do not then any operation on the data will be undefined behaviour.</p>
<p>This concept of agreement goes beyond what the bytes represent (e.g., that some sequence of four bytes should be interpreted as a little-endian, 32 bit, unsigned integer) and includes the safety and validity invariants of the type. These invariants may be due to rules of the language, or due to the specific type itself. What makes this difficult is that invariants due to the language may be specified in a reference or spec, but may just be assumed by the compiler authors and otherwise undocumented. Invariants due to a specific type may be documented but, especially if they are invariants which users would not usually need to be aware of or are considered implementation details, may not be documented (or only documented in the source code). These may still be a concern when writing interop code since C/C++ allows treating data in ways usually forbidden in Rust.</p>
<p>TODO safety and validity invariants - https://www.ralfj.de/blog/2018/08/22/two-kinds-of-invariants.html</p>
<p>Invariants due to specific data types can be found in their documentation or source code. Invariants due to the kind of data types can be found below and in sub-chapters. Rust also has some invariants which apply to all data (or nearly all data), we'll cover those in the next few paragraphs.</p>
<p>Much of Rust's ABI and invariants are de jure undefined and may be subject to change. There have been several RFCs which cover this kind of thing, and work is ongoing within the Rust project and in academia to better specify language-wide invariants. However, there is a large body of code which works today and is unlikely to be broken, so much of this stuff is de facto standardized.</p>
<p>TODO what does this all mean for doing FFI?</p>
<p>TODO there is a two step process c_type -&gt; binding_type -&gt; rust_type, the C and binding types must agree, binding type typically has minimal requirements, binding type to rust type is a pure Rust conversion but to be valid we must establish the invariants of the rust type which may have to be done in foreign code. E.g., <code>int* -&gt; *mut i32 -&gt; &amp;mut i32</code> equivalence of <code>int*</code> and <code>*mut i32</code> is trivial (only wrinkle is the int types), but for the conversion from <code>*mut i32</code> to <code>&amp;mut i32</code>, we must guarantee that the pointer is unique, which depends on what is happening in the foreign code.
- let's break the whole chapter up along these lines</p>
<h3 id="uniqueness-and-mutability"><a class="header" href="#uniqueness-and-mutability">Uniqueness and mutability</a></h3>
<p>In Rust, data is immutable by default. Data must be known to be mutable from its type to be mutated (TODO phrasing). It is undefined behaviour to convert immutable data into mutable data, or to directly mutate immutable data (contrast this to C, where const-ness can be cast away).</p>
<p>Data can be mutated only if it is known to be unique, i.e., data cannot be accessed other than via the reference used to mutate the data. Such uniqueness may be established either statically (e.g., references <code>&amp;T</code> and <code>&amp;mut T</code>) or dynamically (e.g., <code>RefCell</code>). All dynamic tracking of uniqueness must use <code>unsafe</code> and raw pointers code at some level, usually wrapped so that end users only see safe abstractions.</p>
<p>References and values can only be mutated if they are declared as mutable (e.g., a <code>&amp;mut T</code> can be mutated and a <code>&amp;T</code> can never be mutated) and the compiler can prove they are unique at the point mutation occurs (e.g., a <code>&amp;mut T</code> cannot be mutated if there exists a live <code>&amp;T</code> referencing the same value). Raw pointers have the former constraint but not the latter. A <code>*mut T</code> pointer can always be dereferenced (an <code>unsafe</code> operation) and mutated. The programmer must ensure that when the pointer is dereferenced, TODO undefined?</p>
<p>An important aspect of Rust for preserving uniqueness is <em>move semantics</em>. When data is passed from one location to another (e.g., assigned to a variable or passed to a function), it is logically moved (you can think of this as a bitwise copy, then deleting the old copy, although the compiler may optimise that). That means that if data is unique before being passed, it is also unique after being passed. Compare this to C/C++ where data is copied or Java-like languages where passing most data implicitly passes a reference.</p>
<p>Some data in Rust is copied rather than moved. Primitive types, immutable references, raw pointers, and any data structure which implements the <code>Copy</code> marker trait are copied rather than moved.</p>
<p>Note than both moving and copying are simple, bitwise operations. Neither invokes a constructor or destructor (in contrast to C++).</p>
<p>If passing an object from Rust to C/C++, care must be taken around uniqueness. If passing by reference, then pointers/references in C/C++ are copied and so will not be unique. If passing by value, then data will be copied, not moved. Therefore, Rust data which implements <code>Copy</code> can be safely passed by value to C/C++ and passed around or stored. Immutable references/pointers can also be safely passed to C/C++ as long as they are never mutated or data is mutated through them. If non-<code>Copy</code> data is to be passed by value, or data is passed by reference and is mutated, more care must be taken around these invariants.</p>
<p>Invariants around pointer and reference types are covered in detail in the chapter on <a href="reference/TODO">pointers, references, and arrays</a>.</p>
<p>TODO
raw mut pointers
requirement in foreign/unsafe code (interior mutability)
UnsafeCell
scope of requirement (data referenced from Rust? Allocated in Rust?)
validity and safety invariants</p>
<h3 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h3>
<p>TODO
uniqueness
mutable and immutable borrows
overlapping borrows
lifetimes
lifetime due to scope - presence of dtor/attribute? and NLL
drop check and phantomdata
storing data
'static borrows
variance</p>
<h3 id="initialization"><a class="header" href="#initialization">Initialization</a></h3>
<p>In Rust, all memory must always be initialized unless explicitly marked using <a href="https://doc.rust-lang.org/nightly/std/mem/union.MaybeUninit.html"><code>MaybeUninit</code></a>. For most data, it should be ensured that data is initialized on the foreign side of the FFI boundary. If data may not be initialized, then the Rust type must be <code>MaybeUninit</code> (e.g., if passing a <code>Foo</code>, then the Rust type must be <code>MaybeUninit&lt;Foo&gt;</code>). See also the discussion on <code>null</code> in the section below on <code>pointers and references</code>.</p>
<h3 id="concurrency"><a class="header" href="#concurrency">concurrency</a></h3>
<p>TODO
effect on uniqueness
send/sync
unsafe and dynamic guarantees (arc, mutex, scoped threads)
thread-safety and FFI
Rust stuff
thread-safety guarantees from C/C++
atomic/non-atomic access to shared memory (even volatile ops)
memory model is C++20 (nomicon atomics link)</p>
<h3 id="layout-and-alignment"><a class="header" href="#layout-and-alignment">Layout and alignment</a></h3>
<p>TODO
alignment and storage address
size = multiple of alignment
bounds/OOB access
can't assume layout without repr, see structs and enums
DSTs
ZSTs</p>
<h3 id="platform-specific-invariants"><a class="header" href="#platform-specific-invariants">Platform-specific invariants</a></h3>
<p>CHERI
WASM - function/data pointers
ARM?
padding bits
two's compliment</p>
<h2 id="kinds-of-data-type"><a class="header" href="#kinds-of-data-type">Kinds of data type</a></h2>
<p>Rust and C/C++ have many different kinds of data type. These include primitive data, compound data (enums and structs, etc.), pointers, and more. For data to agree across the FFI boundary the kind of data type must correspond (and then the details must agree, which will be covered in the following chapters).</p>
<p>TODO what goes here vs in the sub-chapters?</p>
<h3 id="primitive-types"><a class="header" href="#primitive-types">Primitive types</a></h3>
<p>Primitive types are numeric (signed and unsigned integers, and floating point numbers), characters (but not strings), or booleans. These types have the same semantics and interpretation in C/C++ and in Rust. In particular, they are always passed by simple copying (i.e., without invoking a constructor, nor moved). The names of types and some details of their interpretation varies between C/C++ and Rust, see the chapter on <a href="reference/numerics.html">numeric types</a> for details. In particular, the names of types in both C/C++ and Rust can vary depending on the platform.</p>
<p>Because of the matching semantics and lack of aliasing, using these types for interop is usually very simple and efficient.</p>
<p>Both C and Rust have a void type: <code>void</code> in C and <code>()</code> in Rust (or can be implicit in both languages). These types trivially agree. Most zero-sized types cannot be used for interop, <code>()</code> is an exception when used as a return type, but cannot be used as a type parameter. For void pointers, see the pointers and references section, below.</p>
<h3 id="compound-data"><a class="header" href="#compound-data">Compound data</a></h3>
<p>Compound data types are structs, unions, and enums in C/C++ and Rust, tuples and tuple structs in Rust, and classes in C++. Structs, unions, and some enums basically correspond between C/C++ and Rust, see the following sub-chapters for details. Tuples in Rust cannot be used in FFI because they always have the default representation (see below and the chapter on <a href="reference/TODO">structs, tuples, and unions</a>). Tuple structs correspond with foreign structs. Classes in C++ correspond with structs in Rust (although this is a complex correspondence), see the chapter on <a href="reference/TODO">classes</a>.</p>
<p>Individual compound data types are likely to have their own invariants which will need to be maintained in foreign code (or by Rust code for foreign types).</p>
<p>By default, the Rust compiler can layout data however it likes and this can change between compiler versions (or even for with the same compiler version, in theory). This is incompatible with FFI, and so you must specify an alternative representation for data types for them to agree with a foreign type. We'll cover this in detail in the following sub-chapters.</p>
<p>Aliases (<code>typedef</code> in C++ or <code>type</code> in Rust) are present only at compile time and do not affect the representation or the invariants of the data. Rust's 'newtypes' (usually a tuple struct with a single field) are not aliases and have the same behaviour as other compound types, i.e., can introduce new invariants and may have a different representation (unless explicitly specified), compared with the underlying data.</p>
<p>Strings, smart pointers, and array-like collections (e.g., <code>Vec</code> in Rust) are all compound data types in both Rust and C/C++. In principle, these do not require any special treatment over other user types. However, they are more likely to have important invariants which must be maintained for the sake of soundness. Several examples will be covered in the following sub-chapters.</p>
<h3 id="pointers-and-references"><a class="header" href="#pointers-and-references">pointers and references</a></h3>
<p>TODO</p>
<p>layout - same as C
DSTs/wide pointers
validity: non-null, dangling, unaligned, aliasing (if &amp;mut), pointed-to value is valid (safe?)
smart pointers
void pointers</p>
<h3 id="arrays-and-slices"><a class="header" href="#arrays-and-slices">arrays and slices</a></h3>
<p>TODO</p>
<h3 id="trait-objects-and-class-objects-and-methods"><a class="header" href="#trait-objects-and-class-objects-and-methods">trait objects and class objects, and methods</a></h3>
<p>TODO</p>
<h2 id="generic-types"><a class="header" href="#generic-types">Generic types</a></h2>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="numeric-types"><a class="header" href="#numeric-types">Numeric types</a></h1>
<p>For numeric types to agree across an FFI, their kind (unsigned integer, signed integer, or floating point), size, and invariants must match. The size of most C/C++ types and <code>usize</code>/<code>isize</code> in Rust can vary depending on the platform. For all numeric types, if the size matches then the alignment will also match (on a single platform).</p>
<p><a href="https://doc.rust-lang.org/stable/std/ffi/index.html">std::ffi</a> defines type aliases for common numeric types which are platform-accurate; <a href="https://crates.io/crates/libc">libc</a> defines a few more aliases for less common types. Using these aliases is usually easier than using Rust types directly.</p>
<h2 id="integers-booleans-and-characters"><a class="header" href="#integers-booleans-and-characters">Integers, booleans, and characters</a></h2>
<h3 id="rust-integers"><a class="header" href="#rust-integers">Rust integers</a></h3>
<p><code>u8</code> ... <code>u64</code> and <code>i8</code> ... <code>i64</code> are unsigned and signed respectively with the number in the type indicating the number of bits.</p>
<p><code>usize</code> and <code>isize</code> are 32 bits on 32 bit platforms and 64 bits on 64 bit platforms.</p>
<h3 id="cc-integers"><a class="header" href="#cc-integers">C/C++ integers</a></h3>
<p>A C/C++ integer is unsigned if it uses the <code>unsigned</code> keyword and signed otherwise.</p>
<p>A <code>char</code> is always 8 bits, a <code>short</code> is always 16 bits, and a <code>long long</code> is always 64 bits.</p>
<p>The size of <code>int</code> and <code>long</code> are platform dependent, see <a href="https://github.com/rust-lang/rust/blob/master/library/core/src/ffi/mod.rs#L150">std::ffi::c_{int|long}_definition</a></p>
<h3 id="128-bit-integers"><a class="header" href="#128-bit-integers">128 bit integers</a></h3>
<p>Rust supports <code>i128</code> and <code>u128</code>. These types are mostly <a href="https://github.com/rust-lang/rust/issues/54341">not safe for FFI</a> (will lead to UB) and must be avoided. In particular, they are not compatible with C's 128bit integer types where those exist. However, they can be used on <a href="https://github.com/rust-lang/libc/pull/2719">non-Windows aarch64</a>.</p>
<h3 id="booleans"><a class="header" href="#booleans">booleans</a></h3>
<p>Rust (<code>bool</code>) and C's (strictly, C99 and later, <code>_Bool</code>) boolean types are compatible. Technically, C++'s <code>bool</code> is not guaranteed to be the same representation as C's <code>_Bool</code>, but they are on all known platforms, so it is safe to assume that Rust's <code>bool</code> is compatible with C++'s.</p>
<p>It is common to use integers to represent booleans in C programs (especially older programs or when using older toolchains). These can be converted to Rust <code>bool</code>s if the size matches and they are guaranteed to only have values <code>0</code> or <code>1</code>. (It is possible to use <code>0</code> for false and non-zero for true with C's boolean operators, however, storing any value other than <code>0</code> or <code>1</code> in a Rust <code>bool</code> is UB. You can check and convert in either Rust or C code, but in the latter case you must not use a Rust <code>bool</code> in your FFI).</p>
<h3 id="characters"><a class="header" href="#characters">characters</a></h3>
<p>Rust and C character types are incompatible.</p>
<p>C character types can be converted to or from Rust's 8 bit integer types. <code>unsigned char</code> is always <code>u8</code>, <code>signed char</code> is always <code>i8</code>. <code>char</code> may be either <code>i8</code> or <code>u8</code> depending on the platform, see <a href="https://github.com/rust-lang/rust/blob/master/library/core/src/ffi/mod.rs#L104">std::ffi::c_char_definition</a>.</p>
<p>A Rust <code>char</code> is a 32 bit type which must be a valid <a href="https://www.unicode.org/glossary/#unicode_scalar_value">Unicode scalar value</a>. It is UB to create a <code>char</code> which is not valid Unicode. You should probably avoid using <code>char</code> in FFI unless you have a custom character type with the same size and invariant in your foreign code. Otherwise it is usually better to pass numeric bytes and use helper methods on <a href="https://doc.rust-lang.org/stable/std/primitive.char.html"><code>char</code></a> to create the Rust <code>char</code>.</p>
<p>TODO wchar_t</p>
<h3 id="non-zero-integers"><a class="header" href="#non-zero-integers">Non-zero integers</a></h3>
<p>There are (currently unstable) type aliases for non-zero integers in <code>core::ffi</code>. These map to the non-zero integer types in <a href="https://doc.rust-lang.org/nightly/core/num/index.html"><code>core::num</code></a> with the correct size for the C integer types. The user must maintain the non-zero invariant (whether that is a safety issue depends on how the types are used); i.e., Rust does not ensure that values with this type are in fact non-zero.</p>
<h2 id="floating-point"><a class="header" href="#floating-point">Floating point</a></h2>
<p>A C <code>float</code> is equivalent to a Rust <code>f32</code> and a C <code>double</code> is equivalent to a Rust <code>f64</code>.</p>
<h2 id="simd"><a class="header" href="#simd">SIMD</a></h2>
<p>SIMD vectors cannot be used in FFI (UB). There is an <a href="https://rust-lang.github.io/rfcs/2574-simd-ffi.html">accepted RFC</a> to address this, but it has <a href="https://github.com/rust-lang/rust/issues/63068">not been implemented</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strings"><a class="header" href="#strings">Strings</a></h1>
<p>TODO see string patterns, pointer reference (since C strings are pointers)</p>
<h2 id="rust-c-and-c-strings"><a class="header" href="#rust-c-and-c-strings">Rust, C, and C++ strings</a></h2>
<p>There are many string types in Rust and C/C++. I'll cover them here, focussing on their representations and invariants, since that is what is most important for language interop. For correct FFI, you need to understand a string's layout in memory, whether the string is nul-terminated (and whether nul characters may be embedded within the string), and the encoding of the string (e.g., UTF-8).</p>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<p>Rust has three classes of string types in the standard library, each of which has owned and borrowed<sup class="footnote-reference"><a href="#slices">1</a></sup> types (the latter of which is usually a dynamically sized type, see <a href="reference/TODO">the wide pointer section</a>). The owned type is called a &quot;string&quot; and the borrowed type a &quot;str&quot;. You could also use a sequence of characters or bytes as strings, or define your own custom string type (see the below section on Windows strings for some examples).</p>
<p>The standard Rust string types are <a href="https://doc.rust-lang.org/nightly/std/string/struct.String.html"><code>String</code></a> and <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html"><code>str</code></a>. Both are UTF-8 strings and must always be valid UTF-8. A <code>String</code> is a newtype wrapping a <code>Vec&lt;u8&gt;</code>; <code>str</code> is a built-in type and always has the same representation as a <code>[u8]</code>. This means that a <code>String</code> is a pointer (a unique, non-null pointer to a sequence of <code>u8</code>s, i.e., essentially a <code>*mut u8</code> in terms of representation), a capacity (<code>usize</code>), and length (<code>usize</code>), in that order. A <code>&amp;str</code> is a wide pointer consisting of a (non-null) pointer to a sequence of <code>u8</code>s and a length (<code>usize</code>). However, the order of the components of a wide pointer is unspecified and unstable (i.e., may change in the future).</p>
<p>Rust has the <a href="https://doc.rust-lang.org/nightly/std/ffi/struct.CString.html"><code>std::ffi::CString</code></a> and <a href="https://doc.rust-lang.org/nightly/std/ffi/struct.CStr.html"><code>std::ffi::CStr</code></a> types for working more easily with foreign language string types. These types are <em>not</em> directly FFI compatible with C strings. These strings must be nul-terminated, have no internal nul characters, but do not have to be valid UTF-8. Use the <code>as_ptr</code> method to get a an FFI-compatible pointer. The representation of these strings is not part of their interface.</p>
<p>Similar to <code>CString</code>/<code>CStr</code>, <a href="https://doc.rust-lang.org/nightly/std/ffi/struct.OsString.html"><code>std::ffi::OsString</code></a> and <a href="https://doc.rust-lang.org/nightly/std/ffi/struct.OsStr.html"><code>std::ffi::OsStr</code></a> are meant to make working with foreign string types easier but are <em>not</em> directly FFI compatible with foreign strings. <code>OsString</code>/<code>OsStr</code> are easily convertible to both platform-native strings and Rust strings (<code>String</code>/<code>str</code>). Neither their representation nor whether they are valid Unicode is part of their interface. On Unix platforms, <code>OsStr</code> can be cheaply interconverted with byte slices, however, these are not nul-terminated. On Windows, <code>OsStr</code> can be losslessly converted into a UTF-16 (wide) string, however, this requires copying and processing the string data; again, the output string is not nul-terminated.</p>
<div class="footnote-definition" id="slices"><sup class="footnote-definition-label">1</sup>
<p>technically, these are just dynamically sized string types and are not intrinsically borrowed (e.g., <code>Box&lt;str&gt;</code> is a valid type). However, in practice these types are nearly always used with borrowed references (e.g., <code>&amp;str</code>) to represent borrowed strings. These are often called <em>string slices</em> since they can be a slice (aka substring) of the underlying string.</p>
</div>
<h3 id="c-1"><a class="header" href="#c-1">C</a></h3>
<p>C strings are pointers to a nul-terminated sequence of <code>char</code>s. They may have either pointer or array types (which are equivalent in C). C strings to not have a specified encoding, that is a program is free to interpret a C string as ASCII, UTF-8, UTF-32, or any other encoding.</p>
<h3 id="c-2"><a class="header" href="#c-2">C++</a></h3>
<p>The C++ standard library includes the <code>string</code> type (which is actually an alias of an instantiated generic type <code>basic_string&lt;char&gt;</code>). Like the C string type it does not have a specified encoding. Its methods are all byte-oriented (i.e., have no concept of a character beyond a <code>char</code>). It is not directly compatible with C strings and its representation is not part of its interface. It is easy to get a C string with the <code>c_str</code> method, whether this is guaranteed to return a pointer to the data in the string or a copy of it depends on the version of C++.</p>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>Windows uses many different string types: <code>HSTRING</code>, <code>BSTR</code>, and the <code>PSTR</code> family of types.</p>
<p><a href="https://devblogs.microsoft.com/oldnewthing/20160615-00/?p=93675"><code>HSTRING</code></a> is primarily used with WinRT and is immutable. It is usually (but not always) reference counted. It is nul-terminated, but may also include embedded nuls (it stores a length so doesn't rely on nul-termination). It's UTF-16 encoded. Empty strings are represented as a null pointer.</p>
<p><a href="https://learn.microsoft.com/en-us/archive/blogs/ericlippert/erics-complete-guide-to-bstr-semantics"><code>BSTR</code></a> is primarily used with COM. It is a nul-terminated, mutable, UTF-16 string which may include embedded nuls. A null pointer is a valid <code>BSTR</code> and represents the empty string, though empty <code>BSTR</code>s may also be used. <code>BSTR</code>s always work in conjunction with the system allocator (<code>SysAlloc*</code>) and the length of the string is laid out in memory preceeding the data, and a nul character comes after the data in memory; neither are included in the <code>BSTR</code>'s length. A <code>BSTR</code> is a pointer and points at the first character, not the length.</p>
<p>The <code>PSTR</code> family of types are 'pointer to char's, pointing to a null-terminated sequence of characters (similar to C strings). If there is a <code>C</code> in the name it is an immutable string (otherwise its mutable), if there is a <code>W</code> then the characters are wide (two bytes per character) and the string is UTF-16 encoded. If there is no <code>W</code>, then the characters are one byte and there is no specified encoding (i.e., may be ASCII or UTF-16 or whatever; these are compatible with C strings). An <code>L</code> in the name can be ignored, e.g., <code>PCWSTR</code> and <code>LPCWSTR</code> are the same type.</p>
<p>There are Rust bindings for these types in <a href="https://docs.rs/windows/latest/windows/core/index.html">windows-rs</a> and <a href="https://docs.rs/windows/latest/windows/index.html#macros">macros</a> for creating some of these string types in Rust. The type bindings are best used only for FFI: most are newtype wrappers of raw pointers, so it is very easy to create dangling pointers and other memory safety errors when using them.</p>
<p>Windows primarily uses UTF-16. Rust does not have UTF-16 strings in its standard library (though as mentioned above, OsString can losslessly handle UTF-16). The <a href="https://docs.rs/widestring/latest/widestring/">widestring crate</a> provides types including several UTF-16 string types which can make working with Windows strings much easier.</p>
<h2 id="ffi-with-foreign-strings"><a class="header" href="#ffi-with-foreign-strings">FFI with foreign Strings</a></h2>
<p>For the actual FFI, use the Rust string type which agrees with the foreign string type (see table below).</p>
<div class="table-wrapper"><table><thead><tr><th>Foreign type</th><th>Rust type</th></tr></thead><tbody>
<tr><td>C string <code>[const] char [const] *</code></td><td><code class="hljs">*{const|mut} c_char</code></td></tr>
<tr><td>C++ <code>string</code></td><td><a href="https://cxx.rs/binding/cxxstring.html"><code>cxx::CxxString</code></a></td></tr>
<tr><td><code>HSTRING</code></td><td><a href="https://docs.rs/windows/latest/windows/core/struct.HSTRING.html"><code>windows::core::HSTRING</code></a></td></tr>
<tr><td><code>BSTR</code></td><td><a href="https://docs.rs/windows/latest/windows/core/struct.BSTR.html"><code>windows::core::BSTR</code></a></td></tr>
<tr><td><code>PSTR</code>/<code>LPSTR</code></td><td><a href="https://docs.rs/windows/latest/windows/core/struct.PSTR.html"><code>windows::core::PSTR</code></a></td></tr>
<tr><td><code>PCSTR</code>/<code>LPCSTR</code></td><td><a href="https://docs.rs/windows/latest/windows/core/struct.PCSTR.html"><code>windows::core::PCSTR</code></a></td></tr>
<tr><td><code>PWSTR</code>/<code>LPWSTR</code></td><td><a href="https://docs.rs/windows/latest/windows/core/struct.PWSTR.html"><code>windows::core::PWSTR</code></a></td></tr>
<tr><td><code>PCWSTR</code>/<code>LPCWSTR</code></td><td><a href="https://docs.rs/windows/latest/windows/core/struct.PCWSTR.html"><code>windows::core::PCWSTR</code></a></td></tr>
</tbody></table>
</div>
<p>Creating most of these strings in Rust is usually possible via some macro or conversion function.</p>
<p>The more interesting question is when and how to convert between the FFI-specific types and more standard Rust types (and which types to use). That is out of scope for the reference, but see <a href="reference/TODO">TODO patterns</a>.</p>
<h3 id="memory-management-1"><a class="header" href="#memory-management-1">Memory management</a></h3>
<p>The usual rules of <a href="reference/TODO">memory management with FFI</a> apply: memory must be released in the same language it was allocated, and using borrowed data is easier.</p>
<h2 id="ffi-with-rust-strings"><a class="header" href="#ffi-with-rust-strings">FFI with Rust Strings</a></h2>
<p>It is possible to pass Rust strings across FFI to foreign functions. However, if you are designing an API, it is usually easier to use foreign strings in the FFI and convert these to and from Rust strings internally in Rust code.</p>
<p>If you manipulate the contents of the strings (either in foreign code or unsafe Rust code), then you must respect both the usual invariants around <a href="reference/TODO">pointers</a>, and Rust's string invariants (from <a href="https://doc.rust-lang.org/nightly/std/string/struct.String.html#method.from_raw_parts"><code>String</code> docs</a>):</p>
<ul>
<li>the memory must have be allocated by the same allocator the standard library uses, with a required alignment of exactly 1,</li>
<li>the <code>length</code> of the string must be less than or equal to its <code>capacity</code>,</li>
<li>the <code>capacity</code> of the string must be the correct size of the allocation,</li>
<li>the first <code>length</code> bytes of the string must be valid UTF-8.</li>
</ul>
<p>Note that if you are using the string types in Rust functions with foreign bindings, then you must establish these invariants in the foreign code. Doing so in the Rust code is likely to be unsound.</p>
<p>To pass a Rust string to C++, you can use Cxx's bindings for <a href="https://cxx.rs/binding/string.html"><code>String</code></a> or <a href="https://cxx.rs/binding/str.html"><code>&amp;str</code></a>.</p>
<p>To pass a Rust string to C, you can use a struct with the correct layout (you could look at the standard library source code, or just use the Cxx bindings as a reference).</p>
<h3 id="memory-management-2"><a class="header" href="#memory-management-2">Memory management</a></h3>
<p>The easiest scenario is to create a <code>String</code> in Rust, pass a borrowed <code>&amp;str</code> to foreign code and ensure that the foreign code does not store the pointer, pass it to another thread, call its destructor, or deallocate it.</p>
<p>If you must store the string in foreign code, then you must pass the owned type <code>String</code>. In this case, you must ensure the pointer remains unique (in particular, you must not keep a reference in the Rust code) and pass it back to Rust for destruction.</p>
<p>If you allocate memory for the string in foreign code, then you must not run its destructor in Rust, and you must pass the string back to foreign code for destruction. The easiest way to do that is to pass <code>&amp;str</code> to Rust. If you must pass <code>String</code> (or a raw pointer used to produce a <code>String</code> in Rust code), then you must ensure that there is no copy of the pointer kept in foreign code, and that the pointer is returned to foreign code for destruction. Using a custom reference counted type might be a better alternative, see <a href="reference/TODO">TODO pattern</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resources"><a class="header" href="#resources">Resources</a></h1>
<h2 id="tooling-2"><a class="header" href="#tooling-2">Tooling</a></h2>
<p>Bindgen is the most popular and mature tool and is maintained by the Rust project. It is used to create bindings for C code (and some C++) in Rust code. Cbindgen can be used to create C bindings to Rust code. The other tools below are for C++ interop; cxx is the current favourite tool with the community, but is not suitable for all use cases.</p>
<ul>
<li><a href="https://github.com/rust-lang/rust-bindgen">bindgen</a></li>
<li><a href="https://github.com/eqrion/cbindgen">cbindgen</a></li>
<li><a href="https://cxx.rs/">cxx</a>, <a href="https://github.com/dtolnay/cxx">repo</a></li>
<li><a href="https://github.com/google/autocxx">autocxx</a> (Google tool for 'integrating cxx with bindgen')</li>
<li><a href="https://github.com/rust-diplomat/diplomat">diplomat</a></li>
<li><a href="https://github.com/mystor/rust-cpp">rust-cpp</a> (<code>cpp!</code> macro)</li>
<li><a href="https://github.com/Dushistov/flapigen-rs">flapigen</a> (formerly Swig)</li>
<li><a href="https://github.com/pcwalton/cxx-async">cxx-async</a></li>
<li><a href="https://github.com/Gankra/abi-cafe">ABI Cafe</a> for comparing the output of compilers for ABI compatibility</li>
<li><a href="https://github.com/google/crubit">crubit</a> experimental C++ interop from Chrome folk</li>
</ul>
<p>You may want to use COM/WinRT for inter-language interaction, the best Rust support for COM and WinRT is in <a href="https://github.com/microsoft/windows-rs/">windows-rs</a>.</p>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/nomicon/ffi.html">Nomicon chapter</a></li>
<li><a href="https://michael-f-bryan.github.io/rust-ffi-guide/">Unofficial FFI guide</a></li>
<li><a href="http://jakegoulding.com/rust-ffi-omnibus/">FFI omnibus</a></li>
<li><a href="https://firefox-source-docs.mozilla.org/writing-rust-code/ffi.html">Firefox docs for C++ interop</a></li>
<li>FFI <a href="https://rust-unofficial.github.io/patterns/idioms/ffi/intro.html">idioms</a> and <a href="https://rust-unofficial.github.io/patterns/patterns/ffi/intro.html">patterns</a></li>
<li><a href="https://www.chromium.org/Home/chromium-security/memory-safety/rust-and-c-interoperability/">Chrome docs for C++ interop</a></li>
<li>FFI chapter in <a href="https://anssi-fr.github.io/rust-guide/07_ffi.html">ANSSI-FR Secure Rust Guidelines</a></li>
</ul>
<h2 id="unsafe-programming"><a class="header" href="#unsafe-programming">Unsafe programming</a></h2>
<p>Resources for learning about unsafe programming:</p>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html">Chapter</a> in The Book.</li>
<li><a href="https://doc.rust-lang.org/nomicon">Nomicon</a></li>
<li>Unsafe code guidelines
<ul>
<li><a href="https://rust-lang.github.io/unsafe-code-guidelines">rendered</a></li>
<li><a href="https://github.com/rust-lang/unsafe-code-guidelines">repo</a></li>
<li><a href="https://github.com/rust-lang/unsafe-code-guidelines/issues">issues</a></li>
</ul>
</li>
<li><a href="https://publikationen.sulb.uni-saarland.de/handle/20.500.11880/29647">Ralf's thesis</a></li>
<li><a href="https://plv.mpi-sws.org/rustbelt/stacked-borrows/paper.pdf">Stacked borrows paper</a></li>
<li><a href="http://plv.mpi-sws.org/rustbelt/ghostcell/paper.pdf">GhostCell paper</a></li>
<li><a href="https://www.ralfj.de/blog/">Ralf's blog</a></li>
<li><a href="https://gankra.github.io/blah/papers/thesis.pdf">Gankra's thesis</a></li>
<li><a href="https://gankra.github.io/blah/#articles">Gankra's blog</a></li>
<li><a href="https://github.com/rust-lang/miri/">MIRI repo</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
