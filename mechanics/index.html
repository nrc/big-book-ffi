<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Bindings and representations - The Big Book of Rust Interop</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../intro.html">Introduction</a></li><li class="chapter-item expanded "><a href="../overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="../estimating.html"><strong aria-hidden="true">2.</strong> Assessing/estimating interop complexity</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Building and linking</div></li><li class="chapter-item expanded "><a href="../mechanics/index.html" class="active"><strong aria-hidden="true">4.</strong> Bindings and representations</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Building an abstraction layer</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Modularisation</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> Safety</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Ownership and memory management - mem::forget</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.</strong> FFI types and idiomatic types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> Error handling</div></li></ol></li><li class="chapter-item expanded "><a href="../patterns/index.html"><strong aria-hidden="true">6.</strong> Patterns</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../patterns/layered.html"><strong aria-hidden="true">6.1.</strong> Layered library design</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Case studies</div></li><li class="chapter-item expanded "><a href="../reference/index.html"><strong aria-hidden="true">8.</strong> Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/functions.html"><strong aria-hidden="true">8.1.</strong> Functions and methods</a></li><li class="chapter-item expanded "><a href="../reference/data-types.html"><strong aria-hidden="true">8.2.</strong> Data types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/numerics.html"><strong aria-hidden="true">8.2.1.</strong> Numeric types</a></li><li class="chapter-item expanded "><a href="../reference/strings.html"><strong aria-hidden="true">8.2.2.</strong> Strings</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../resources.html"><strong aria-hidden="true">9.</strong> Resources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Big Book of Rust Interop</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-mechanics-of-ffi"><a class="header" href="#the-mechanics-of-ffi">The mechanics of FFI</a></h1>
<p>No runtime, bare metal means low-level interop is free</p>
<p>where the ABI of Rust and foreign lang coincide, interop is free. Where it doesn't we require abstraction layer work
stable and de facto stable Rust ABI</p>
<p>function calls and data must agree</p>
<p>runtime behaviour
async/concurrency
unwinding</p>
<h2 id="declaring-and-defining-functions"><a class="header" href="#declaring-and-defining-functions">Declaring and defining functions</a></h2>
<p>For a function to be called across languages, it must be declared in both languages (but only defined in one) so that both compilers can find it. The two declarations must end up associated with the same definition, and this requires linking object files correctly, see the chapter on <a href="TODO">building and linking</a> for details. If declared correctly, calling the function requires no special effort and no runtime overhead (it can even be inlined across languages if using link-time optimisation (LTO)).</p>
<p>TODO dyn linking
TODO calling is unsafe</p>
<p>Global variables can also be accessed across the FFI boundary, see the <a href="TODO">reference</a> chapter.</p>
<h3 id="function-defined-in-rust"><a class="header" href="#function-defined-in-rust">Function defined in Rust</a></h3>
<p>This section will cover defining a Rust function which can be called from a foreign language.</p>
<p>For a Rust function to be callable from a foreign language you must use the <code>extern</code> keyword to specify the ABI. <code>&quot;C&quot;</code> is the default and most common option, see the reference for a full list. If the function should be name-able from outside Rust, you should use the <code>#[no_mangle]</code> attribute to prevent name mangling. You'll usually need this, unless the function is only used via a function pointer.</p>
<p>E.g.,</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn foo() -&gt; i32 {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>You'll need to declare the function in foreign code to use it. In C/C++ this will look the same as declaring a C function (usually declared in headers as required). E.g.,</p>
<pre><code class="language-C">int foo();
</code></pre>
<h3 id="function-defined-in-cc"><a class="header" href="#function-defined-in-cc">Function defined in C/C++</a></h3>
<p>This section will cover defining a C/C++ function which can be called from Rust.</p>
<p>A function defined in C/C++ will be just a regular function, just don't declare it <code>static</code> (the default is <code>extern</code>, which is what we want).</p>
<p>In Rust the function must be declared. This is done inside an <code>extern block</code>. Functions declared in an <code>extern</code> block may not have bodies, are implicitly unsafe to call, and have a specified ABI (<code>&quot;C&quot;</code> by default). Various attributes control how function definitions are discovered and linked, see the <a href="TODO">reference</a>.</p>
<p>E.g.,</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern &quot;C&quot; {
    fn foo() -&gt; i32;
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="data"><a class="header" href="#data">Data</a></h2>
<p>When data is passed across the FFI boundary, its type must be known on both sides (i.e., there must be declarations in both languages) and those types must be compatible. Compatibility involves both a type's representation (how it is laid out in memory) and invariants of the type (due to either the language or the type itself). Compatibility is not quite a symmetric relation because while the representations must match, the invariants must be the same or stronger on the callee side than the caller side. Where representations are compatible but invariants are not, the missing invariants can be made requirements for the caller to satisfy. Compatibility is also platform-dependent since different syntactic types may have different representations on different platforms.</p>
<p>Type compatibility is a big topic. We'll summarise here and give a complete description in the <a href="TODO">reference</a>.</p>
<p><a href="https://doc.rust-lang.org/stable/std/ffi/index.html">std::ffi</a> defines type aliases for common numeric types which are platform-accurate; <a href="https://crates.io/crates/libc">libc</a> defines a few more aliases for less common types. Using these aliases is usually easier than using Rust types directly.</p>
<p>Primitive types (integers, floating point types, and booleans) are straightforwardly compatible, though the names are different in C and Rust and the correspondence is platform-dependent (using <code>std::ffi</code> in Rust is the easiest solution). Characters are also a primitive type in C and Rust, but have different sizes and encodings in the different languages. C <code>char</code>s are compatible with Rust's <code>i8</code> or <code>u8</code> . A Rust <code>char</code> is compatible with a C <code>unsigned int</code> or <code>unsigned long</code>, however, a Rust <code>char</code> must always be a valid <a href="https://www.unicode.org/glossary/#unicode_scalar_value">Unicode scalar value</a>, this requirement must be satisfied in the C code before the data has the Rust <code>char</code> type.</p>
<p>If <code>T_rust</code> and <code>T_c</code> correspond, then <code>*const T_rust</code> and <code>const T_c*</code> correspond, and <code>*mut T_rust</code> and <code>T_c*</code> correspond. When calling foreign functions from Rust code, you can use <code>&amp;mut T_rust</code> and <code>&amp;T_rust</code>, respectively in the Rust function declaration (Rust references and raw pointers have the same representation). You can also use <code>Option&lt;&amp;mut T_rust&gt;</code> and <code>Option&lt;&amp;T_rust&gt;</code>, see the discussion on enums, below. You cannot do this in the opposite direction (i.e., use a Rust reference in a Rust function definition and a pointer in the C declaration), since the Rust reference types have more invariants which must be satisfied. (You technically can do this without any compile-time errors and require the additional invariants in the foreign code, however, these invariants are difficult to guarantee and failing to do so will cause undefined behaviour).</p>
<p>TODO ^ the pointees don't have to correspond fully. Box, Rc, etc.</p>
<p>C and Rust structs are compatible if they have corresponding fields and the field types are compatible (and the Rust struct is <code>repr(C)</code>). Sometimes a C struct may have hidden fields (sometimes called an opaque struct). Such types can be represented in Rust as a zero-sized type with a private field and no constructor function (so the type cannot be instantiated), you can include a field with type <code>PhantomData&lt;(*mut u8, PhantomPinned)&gt;</code> to prevent the type implementing the <code>Send</code>, <code>Sync</code>, or <code>Unpin</code> auto-traits. See the <a href="TODO">opaque struct pattern</a> for more.</p>
<p>C and Rust unions are compatible if the the Rust union is <code>repr(C)</code> and their fields are compatible. Field compatibility is a bit more complex than for structs: the unions must end up the same size and any pair of fields which are used together must be compatible. It is up to the programmer to ensure compatible usage of the unions.</p>
<p>Rust enums with no embedded data which are <code>repr(C)</code> are compatible with C++ enums if they have the same number of variants, the specified (or implicit) determinant types match, and the values of all variants match. It is possible to loosen these restrictions slightly. It is <em>invalid</em> for an enum to have a value which is not a declared variant. So as long as there is a Rust variant which matches any C++ variant which may be passed across the FFI boundary, the enums are compatible.</p>
<p>Enums which are 'option-like' (i.e., have two variants, one with a single field and one with no embedded data) and where the payload type is a non-null pointer type are compatible with the corresponding (nullable) pointer type in C/C++. E.g., <code>Option&lt;&amp;Foo&gt;</code> is compatible with <code>const Foo*</code> (subject to the restrictions described above for pointer compatibility). Similarly an option-like enum with the <a href="https://doc.rust-lang.org/nightly/std/num/index.html">non-zero numeric types</a> is compatible with the (zero-able) numeric type in C/C++.</p>
<p>Most tuple types are incompatible with C/C++ types because their representation cannot be specified. The exception is the empty tuple, <code>()</code> which is compatible with the <code>void</code> type in C/C++ when passed by pointer.</p>
<p>In general, zero-sized types are incompatible with foreign types.</p>
<p>C strings are pointers to <code>char</code>s and as expected are compatible with <code>*mut u8</code> or <code>*mut i8</code>. Despite their resident module, <code>std::ffi::CStr/CString</code> should not be used directly for FFI because their representations are not guaranteed.</p>
<p>TODO C++ types</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../estimating.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../patterns/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../estimating.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../patterns/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
